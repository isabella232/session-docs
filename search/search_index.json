{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Session \u00b6 Information is Important \u00b6 Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications. Download Links \u00b6 Head over to the Session website to get your Session download Links: Download Register Session Name \u00b6 Head over to the How to register Session/Wallet name guide . Introduction \u00b6 Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Home"},{"location":"#session","text":"","title":"Session"},{"location":"#information-is-important","text":"Privacy is having the agency to decide when you reveal personal information. It is a particularly valuable quality today, when the collection and storage of personal data is taking place at unprecedented levels in history. Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications.","title":"Information is Important"},{"location":"#download-links","text":"Head over to the Session website to get your Session download Links: Download","title":"Download Links"},{"location":"#register-session-name","text":"Head over to the How to register Session/Wallet name guide .","title":"Register Session Name"},{"location":"#introduction","text":"Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Introduction"},{"location":"FAQ/","text":"Frequently Asked Questions \u00b6 What is Session? why should I trust Session? What will Session do if compelled by a court to reveal user identities? How do I contact Session? How does Session protect my identity? What is metadata and why does Session need to protect it? What are the differences between Session on mobile and Session on desktop? What is an onion routing network? What is proxy routing, and how is it different from onion routing? How do I know if the person I am talking to is the person I want to talk to? What are channels, and do they protect my privacy in the same way as person-to-person messages? What are private group chats, and how do they compare with channels? If my phone is taken from me, can someone access my messages? Can I share attachments with my contacts? If so, does the app strip metadata from those attachments? Session \u00b6 What is Session? \u00b6 Session is a secure messaging app that protects your metadata, encrypts your communications and makes sure your messaging activities leave no digital trail behind. Why should I trust Session? \u00b6 Conversations in Session are end-to-end encrypted, just as in most private messengers. However, when you use Session, the identities of the people communicating are also protected. Session keeps your communication private, secure and anonymous. When using Session Desktop, your messages are sent to their destinations through Lokinet, a decentralised onion routing network similar to Tor (with a few key differences). Lokinet protects user privacy by ensuring that no single server ever knows a message's origin and destination. For more on this, check out What is an onion routing network? While Lokinet is being finished on mobile, Session\u2019s Android and iOS clients use proxy routing to protect IP addresses and maintain anonymity. For more on the difference between desktop and mobile, check out \"What is proxy routing?\" below. Session\u2019s code is open-source and can be independently audited at any time. Session is a project of the Loki Foundation, a not-for-profit organisation whose mission is to provide the world with better access to digital privacy technologies. What will Session do if compelled by a court to reveal user identities? \u00b6 As Session is a project of the Loki Foundation, court orders in situations such as this would be targeted at the Foundation. The Loki Foundation would comply with lawful orders. However, the Loki Foundation could not reveal user identities simply because the Foundation does not have access to the data required to do so. Session account creation does not use or require email addresses or phone numbers. Session IDs (which are public keys) are recorded, but there is no link between a public key and a person's real identity, and due to Session's decentralised network, there's also no way to link a Session ID to a specific IP address. The most the Loki Foundation could provide, if compelled to do so, would be tangential information such as access logs for the getsession.org website or statistics collected by the Apple App Store or Google Play Store. How do I contact Session? \u00b6 Got questions, comments or suggestions? Contact the team behind Session at team@loki.network or reach out to Session on social media. How does Session protect my identity? \u00b6 You don\u2019t need a mobile number or an email to make an account with Session. Your display name can be your real name, an alias, or anything else you like. Session does not collect any geolocation data, metadata or any other data about the device or network you are using. Session Desktop messages are sent over Lokinet, Session's decentralised onion routing solution, so no remote servers are ever able to trace or track your conversations. And on mobile, Session uses secure proxy routing to keep your identity private. For more on Session's secure message routing, check out \"What is an onion routing network?\" and \"What is proxy routing?\" What is metadata and why does Session need to protect it? \u00b6 In messaging apps, metadata is the information created when you send a message \u2014 everything about the message besides the actual contents of the message itself. This can include information like your IP address, the IP addresses of your contacts, who your messages are sent to, and the time and date that messages are sent. It\u2019s impossible for Session to track users\u2019 IP addresses because the app uses onion routing (on desktop) and proxy routing (on mobile) to send messages. Because Session doesn\u2019t use central servers to route messages from person to person, we don\u2019t know when you send messages, or who you send them to. Session lets you send messages \u2014 not metadata. What are the differences between Session on mobile and Session on desktop? \u00b6 As mentioned in \"What is proxy routing\" below, mobile devices use an alternative form of anonymous routing, called proxy routing, to protect user IP addresses. This is a temporary measure which will be replaced by Lokinet when the latter has mobile client functionality. Other than this, mobile and desktop Session clients have feature parity. What is an onion routing network? \u00b6 An onion routing network is a network of nodes over which users can send anonymous encrypted messages. Onion networks encrypt messages with multiple layers of encryption, then send them through a number of nodes. Each node \u2018unwraps\u2019 (decrypts) a layer of encryption, meaning that no single node ever knows both the destination and origin of the message. Session uses onion routing to ensure that a server which receives a message never knows the IP address of the sender. Session uses the Loki Project\u2019s Lokinet onion routing network to send messages securely and anonymously. Lokinet is built on a foundation of Loki Service Nodes, which also power the $LOKI cryptocurrency. Check out Loki.network for more information on the tech behind Session\u2019s onion routing. What is proxy routing, and how is it different from onion routing? \u00b6 Session\u2019s desktop client uses the Lokinet onion routing network to send messages, but due to platform-specific limitations, Lokinet is not yet available on mobile devices. While we work to make Lokinet available on mobile, we have implemented an interim solution: proxy routing. Instead of connecting directly to a Loki Service Node to send or receive messages, mobile devices connect to a service node which then connects to a second service node on behalf of the mobile device. The first service node then sends or requests messages from the second node on behalf of the mobile device. This proxy routing system ensures that the client device\u2019s IP address is never known by the service node which fetches or sends the messages. However, proxy routing does provide weaker privacy than the Lokinet onion routing protocol used by Session\u2019s desktop client. Proxy routing still provides a high level of security for minimising metadata leakage on mobile. The proxy routing system will be replaced by full Lokinet integration when Lokinet clients are ready for mobile devices. How do I know if the person I am talking to is the person I want to talk to? \u00b6 Session's \"Safety Numbers\" feature makes it easy for people in a conversation to verify each other if both parties would like to do so. You can use another channel of communication outside of Session to ask for and verify someone's Session Safety Number, and then check that the Safety Number in the app matches what you've been told. If the Safety Numbers match, you're speaking to the correct person. If they do not, the Session account may be an imposter. What are channels, and do they protect my privacy in the same way as person-to-person messages? \u00b6 The short answer: channels are not as private as person-to-person messages. The long answer: channels are large public channels where Session users can congregate and discuss anything they want. Channels, unlike other services in Session, are self-hosted and thus not fully decentralised. Someone has to run a server which stores the public chat's message history. Additionally, because channel servers can serve thousands of users, messages are only encrypted in transit to the server rather than being fully end-to-end encrypted. For smaller group chats with a higher degree of privacy, users are encouraged to use private group chats. You can find out more about channels and private group chats here . What are private group chats, and how do they compare with channels? \u00b6 Private group chats are fully end-to-end encrypted group chats. Up to 10 people can participate in a private group chat. Private group chat messages are stored on Session's decentralised network, with no central servers used or required. If my phone is taken from me, can someone access my messages? \u00b6 Session allows users to encrypt their local Session database with a PIN code. With this feature turned on, your messages cannot be accessed without knowing your PIN code. Can I share attachments with my contacts? If so, does the app strip metadata from those attachments? \u00b6 Session can send files, images and other attachments up to 10MB in both person-to-person messages and group chats. By default, Session uses the Loki File Server for attachment sending and storage. The Loki File Server is an open-source file server run by the Loki Foundation \u2014 the creators of Session. When you send an attachment, the file is symmetrically encrypted on the device and then sent to the Loki File Server. To send the attachment to a friend, Session sends them an encrypted message containing the link, plus the decryption key for the file. This ensures that the Loki File Server can never see the contents of files being uploaded to it. Additionally, the desktop and mobile versions of Session use onion routing and proxy routing (respectively) to hide users' IP addresses when uploading or downloading attachments from the Loki File Server. In future, you will be able to configure the Session app to use a custom file server, such as a self-hosted server or VPS (Virtual Private Server), if you would prefer not to use a file server hosted by the Loki Foundation.","title":"Session Docs | Frequently Asked Questions"},{"location":"FAQ/#frequently-asked-questions","text":"What is Session? why should I trust Session? What will Session do if compelled by a court to reveal user identities? How do I contact Session? How does Session protect my identity? What is metadata and why does Session need to protect it? What are the differences between Session on mobile and Session on desktop? What is an onion routing network? What is proxy routing, and how is it different from onion routing? How do I know if the person I am talking to is the person I want to talk to? What are channels, and do they protect my privacy in the same way as person-to-person messages? What are private group chats, and how do they compare with channels? If my phone is taken from me, can someone access my messages? Can I share attachments with my contacts? If so, does the app strip metadata from those attachments?","title":"Frequently Asked Questions"},{"location":"FAQ/#session","text":"","title":"Session"},{"location":"FAQ/#what-is-session","text":"Session is a secure messaging app that protects your metadata, encrypts your communications and makes sure your messaging activities leave no digital trail behind.","title":"What is Session?"},{"location":"FAQ/#why-should-i-trust-session","text":"Conversations in Session are end-to-end encrypted, just as in most private messengers. However, when you use Session, the identities of the people communicating are also protected. Session keeps your communication private, secure and anonymous. When using Session Desktop, your messages are sent to their destinations through Lokinet, a decentralised onion routing network similar to Tor (with a few key differences). Lokinet protects user privacy by ensuring that no single server ever knows a message's origin and destination. For more on this, check out What is an onion routing network? While Lokinet is being finished on mobile, Session\u2019s Android and iOS clients use proxy routing to protect IP addresses and maintain anonymity. For more on the difference between desktop and mobile, check out \"What is proxy routing?\" below. Session\u2019s code is open-source and can be independently audited at any time. Session is a project of the Loki Foundation, a not-for-profit organisation whose mission is to provide the world with better access to digital privacy technologies.","title":"Why should I trust Session?"},{"location":"FAQ/#what-will-session-do-if-compelled-by-a-court-to-reveal-user-identities","text":"As Session is a project of the Loki Foundation, court orders in situations such as this would be targeted at the Foundation. The Loki Foundation would comply with lawful orders. However, the Loki Foundation could not reveal user identities simply because the Foundation does not have access to the data required to do so. Session account creation does not use or require email addresses or phone numbers. Session IDs (which are public keys) are recorded, but there is no link between a public key and a person's real identity, and due to Session's decentralised network, there's also no way to link a Session ID to a specific IP address. The most the Loki Foundation could provide, if compelled to do so, would be tangential information such as access logs for the getsession.org website or statistics collected by the Apple App Store or Google Play Store.","title":"What will Session do if compelled by a court to reveal user identities?"},{"location":"FAQ/#how-do-i-contact-session","text":"Got questions, comments or suggestions? Contact the team behind Session at team@loki.network or reach out to Session on social media.","title":"How do I contact Session?"},{"location":"FAQ/#how-does-session-protect-my-identity","text":"You don\u2019t need a mobile number or an email to make an account with Session. Your display name can be your real name, an alias, or anything else you like. Session does not collect any geolocation data, metadata or any other data about the device or network you are using. Session Desktop messages are sent over Lokinet, Session's decentralised onion routing solution, so no remote servers are ever able to trace or track your conversations. And on mobile, Session uses secure proxy routing to keep your identity private. For more on Session's secure message routing, check out \"What is an onion routing network?\" and \"What is proxy routing?\"","title":"How does Session protect my identity?"},{"location":"FAQ/#what-is-metadata-and-why-does-session-need-to-protect-it","text":"In messaging apps, metadata is the information created when you send a message \u2014 everything about the message besides the actual contents of the message itself. This can include information like your IP address, the IP addresses of your contacts, who your messages are sent to, and the time and date that messages are sent. It\u2019s impossible for Session to track users\u2019 IP addresses because the app uses onion routing (on desktop) and proxy routing (on mobile) to send messages. Because Session doesn\u2019t use central servers to route messages from person to person, we don\u2019t know when you send messages, or who you send them to. Session lets you send messages \u2014 not metadata.","title":"What is metadata and why does Session need to protect it?"},{"location":"FAQ/#what-are-the-differences-between-session-on-mobile-and-session-on-desktop","text":"As mentioned in \"What is proxy routing\" below, mobile devices use an alternative form of anonymous routing, called proxy routing, to protect user IP addresses. This is a temporary measure which will be replaced by Lokinet when the latter has mobile client functionality. Other than this, mobile and desktop Session clients have feature parity.","title":"What are the differences between Session on mobile and Session on desktop?"},{"location":"FAQ/#what-is-an-onion-routing-network","text":"An onion routing network is a network of nodes over which users can send anonymous encrypted messages. Onion networks encrypt messages with multiple layers of encryption, then send them through a number of nodes. Each node \u2018unwraps\u2019 (decrypts) a layer of encryption, meaning that no single node ever knows both the destination and origin of the message. Session uses onion routing to ensure that a server which receives a message never knows the IP address of the sender. Session uses the Loki Project\u2019s Lokinet onion routing network to send messages securely and anonymously. Lokinet is built on a foundation of Loki Service Nodes, which also power the $LOKI cryptocurrency. Check out Loki.network for more information on the tech behind Session\u2019s onion routing.","title":"What is an onion routing network?"},{"location":"FAQ/#what-is-proxy-routing-and-how-is-it-different-from-onion-routing","text":"Session\u2019s desktop client uses the Lokinet onion routing network to send messages, but due to platform-specific limitations, Lokinet is not yet available on mobile devices. While we work to make Lokinet available on mobile, we have implemented an interim solution: proxy routing. Instead of connecting directly to a Loki Service Node to send or receive messages, mobile devices connect to a service node which then connects to a second service node on behalf of the mobile device. The first service node then sends or requests messages from the second node on behalf of the mobile device. This proxy routing system ensures that the client device\u2019s IP address is never known by the service node which fetches or sends the messages. However, proxy routing does provide weaker privacy than the Lokinet onion routing protocol used by Session\u2019s desktop client. Proxy routing still provides a high level of security for minimising metadata leakage on mobile. The proxy routing system will be replaced by full Lokinet integration when Lokinet clients are ready for mobile devices.","title":"What is proxy routing, and how is it different from onion routing?"},{"location":"FAQ/#how-do-i-know-if-the-person-i-am-talking-to-is-the-person-i-want-to-talk-to","text":"Session's \"Safety Numbers\" feature makes it easy for people in a conversation to verify each other if both parties would like to do so. You can use another channel of communication outside of Session to ask for and verify someone's Session Safety Number, and then check that the Safety Number in the app matches what you've been told. If the Safety Numbers match, you're speaking to the correct person. If they do not, the Session account may be an imposter.","title":"How do I know if the person I am talking to is the person I want to talk to?"},{"location":"FAQ/#what-are-channels-and-do-they-protect-my-privacy-in-the-same-way-as-person-to-person-messages","text":"The short answer: channels are not as private as person-to-person messages. The long answer: channels are large public channels where Session users can congregate and discuss anything they want. Channels, unlike other services in Session, are self-hosted and thus not fully decentralised. Someone has to run a server which stores the public chat's message history. Additionally, because channel servers can serve thousands of users, messages are only encrypted in transit to the server rather than being fully end-to-end encrypted. For smaller group chats with a higher degree of privacy, users are encouraged to use private group chats. You can find out more about channels and private group chats here .","title":"What are channels, and do they protect my privacy in the same way as person-to-person messages?"},{"location":"FAQ/#what-are-private-group-chats-and-how-do-they-compare-with-channels","text":"Private group chats are fully end-to-end encrypted group chats. Up to 10 people can participate in a private group chat. Private group chat messages are stored on Session's decentralised network, with no central servers used or required.","title":"What are private group chats, and how do they compare with channels?"},{"location":"FAQ/#if-my-phone-is-taken-from-me-can-someone-access-my-messages","text":"Session allows users to encrypt their local Session database with a PIN code. With this feature turned on, your messages cannot be accessed without knowing your PIN code.","title":"If my phone is taken from me, can someone access my messages?"},{"location":"FAQ/#can-i-share-attachments-with-my-contacts-if-so-does-the-app-strip-metadata-from-those-attachments","text":"Session can send files, images and other attachments up to 10MB in both person-to-person messages and group chats. By default, Session uses the Loki File Server for attachment sending and storage. The Loki File Server is an open-source file server run by the Loki Foundation \u2014 the creators of Session. When you send an attachment, the file is symmetrically encrypted on the device and then sent to the Loki File Server. To send the attachment to a friend, Session sends them an encrypted message containing the link, plus the decryption key for the file. This ensures that the Loki File Server can never see the contents of files being uploaded to it. Additionally, the desktop and mobile versions of Session use onion routing and proxy routing (respectively) to hide users' IP addresses when uploading or downloading attachments from the Loki File Server. In future, you will be able to configure the Session app to use a custom file server, such as a self-hosted server or VPS (Virtual Private Server), if you would prefer not to use a file server hosted by the Loki Foundation.","title":"Can I share attachments with my contacts? If so, does the app strip metadata from those attachments?"},{"location":"Messenger/HowToRegisterSessionNames/","text":"How to register an LNS mapping \u00b6 LNS mapping registration will be supported in the CLI wallet at launch. The following steps can be used to register and update LNS mappings in the CLI wallet. Note that you can access a detailed description of each command within the app by using help <command_name> . Purchasing a Loki Name Service record \u00b6 Purchasing an LNS record in the CLI wallet uses the lns_buy_mapping command. All arguments for the lns_buy_mapping command are optional except for the <name> and <value> that the name maps to. lns_buy_mapping [index=<N1>[,<N2>,...]] [<priority>] [owner=<value>] [backup_owner=<value>] <name> <value> Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying is the owner of the record. lns_buy_mapping KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying the mapping is the owner of the record, but specifies a backup owner who will also be authorised to update the record. lns_buy_mapping backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. You buy on behalf of another wallet T6UD8..ppir and specify another backup wallet. lns_buy_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Updating a Loki Name Service record: Wallet executing update is owner of record \u00b6 Updating an LNS record in the CLI wallet uses the lns_update_mapping command. All arguments for the lns_update_mapping command are optional except the name of the record to update, and at least one field of the record to update ( owner , backup_owner , or value ). The [signature] argument is for deferring updates to the record, and is explained in detail in the next section. lns_update_mapping [owner=<value>] [backup_owner=<value>] [value=<lns_value>] [signature=<hex_signature>] <name> Example: Updating the owner of the record (essentially transferring ownership \u2014 after changing ownership, you will no longer be authorised to update the record). lns_update_mapping owner=T6UC1nSy2289uX8R2jS3ci7y6eNnVdvhSQRoZtckPzmrQgJ3CyUhUtxgxuedusx9TCKVhZZBCuwFkKoJ3joXStWh1QozRsXXo KeeJef Note: At this time you can only update Session ID mappings, you cannot yet add a wallet address mapping to your name \u2014 this will require additional changes which will be implemented at a later date. Example: Update all fields of the mapping. lns_update_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=0596d2fdc1407490e1bb7cbca3f3674606d3ef9b1d01cf46199ee5c8932d83f40a KeeJef Updating a Loki Name Service Record: Wallet executing is not owner of record) \u00b6 In this scenario, you have a LNS record that you wish to update, and you\u2019re able to coordinate with the wallet owning the record. The wallet that owns the record can execute this command to generate a signature. lns_make_update_mapping_signature [owner=<value>] [backup_owner=<value>] [value=<lns_value>] <name> Example: User transfers ownership of a record to another person T6TEJ...t3x with the value 058c...c08. The original owner generates a signature. lns_make_update_mapping_signature owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 KeeJef The generated signature: 3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead On the wallet to execute, the arguments must match the arguments specified in the lns_make_update_mapping_signature with the added signature argument. lns_update_mapping owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 signature=3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead KeeJef","title":"Register Session/Wallet names"},{"location":"Messenger/HowToRegisterSessionNames/#how-to-register-an-lns-mapping","text":"LNS mapping registration will be supported in the CLI wallet at launch. The following steps can be used to register and update LNS mappings in the CLI wallet. Note that you can access a detailed description of each command within the app by using help <command_name> .","title":"How to register an LNS mapping"},{"location":"Messenger/HowToRegisterSessionNames/#purchasing-a-loki-name-service-record","text":"Purchasing an LNS record in the CLI wallet uses the lns_buy_mapping command. All arguments for the lns_buy_mapping command are optional except for the <name> and <value> that the name maps to. lns_buy_mapping [index=<N1>[,<N2>,...]] [<priority>] [owner=<value>] [backup_owner=<value>] <name> <value> Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying is the owner of the record. lns_buy_mapping KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. The wallet buying the mapping is the owner of the record, but specifies a backup owner who will also be authorised to update the record. lns_buy_mapping backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Example: Buy a LNS record that maps \u2018KeeJef\u2019 to a Session Public Key, 053 \u2026 254. You buy on behalf of another wallet T6UD8..ppir and specify another backup wallet. lns_buy_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6U7AaNgN2cARpR7CNHGChGMjsmjq5ffh4hLa4DjUUXtKS3bPy2rKTX614RxmpPPX6KjZzqUSSpAEcoghASTXqvP1qMsJzWch KeeJef 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254","title":"Purchasing a Loki Name Service record"},{"location":"Messenger/HowToRegisterSessionNames/#updating-a-loki-name-service-record-wallet-executing-update-is-owner-of-record","text":"Updating an LNS record in the CLI wallet uses the lns_update_mapping command. All arguments for the lns_update_mapping command are optional except the name of the record to update, and at least one field of the record to update ( owner , backup_owner , or value ). The [signature] argument is for deferring updates to the record, and is explained in detail in the next section. lns_update_mapping [owner=<value>] [backup_owner=<value>] [value=<lns_value>] [signature=<hex_signature>] <name> Example: Updating the owner of the record (essentially transferring ownership \u2014 after changing ownership, you will no longer be authorised to update the record). lns_update_mapping owner=T6UC1nSy2289uX8R2jS3ci7y6eNnVdvhSQRoZtckPzmrQgJ3CyUhUtxgxuedusx9TCKVhZZBCuwFkKoJ3joXStWh1QozRsXXo KeeJef Note: At this time you can only update Session ID mappings, you cannot yet add a wallet address mapping to your name \u2014 this will require additional changes which will be implemented at a later date. Example: Update all fields of the mapping. lns_update_mapping owner=T6UD8TM1t7mUYmMCHXQ67Kg5jXBwoVxNqGpXctnsLXtGBEFnhq37RQAA8jgqgD9U6QbeNGqAkkVXucXQ5txE6Mrk2aRwpppir backup_owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=0596d2fdc1407490e1bb7cbca3f3674606d3ef9b1d01cf46199ee5c8932d83f40a KeeJef","title":"Updating a Loki Name Service record: Wallet executing update is owner of record"},{"location":"Messenger/HowToRegisterSessionNames/#updating-a-loki-name-service-record-wallet-executing-is-not-owner-of-record","text":"In this scenario, you have a LNS record that you wish to update, and you\u2019re able to coordinate with the wallet owning the record. The wallet that owns the record can execute this command to generate a signature. lns_make_update_mapping_signature [owner=<value>] [backup_owner=<value>] [value=<lns_value>] <name> Example: User transfers ownership of a record to another person T6TEJ...t3x with the value 058c...c08. The original owner generates a signature. lns_make_update_mapping_signature owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 KeeJef The generated signature: 3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead On the wallet to execute, the arguments must match the arguments specified in the lns_make_update_mapping_signature with the added signature argument. lns_update_mapping owner=T6TEJJRfvhMZbJpRuchJtmQAjuyCUAyYy2yVcc9ySxTHXWgwQkupjUJUQsyCoyYfRGReAY3pgaYxUHwoKEkWNh5o2qe5Btt3x value=058c72182ecf25172999414f098f91c07bcf12eae7e0c810659f533e81dc865c08 signature=3ede65e0a78eca500549dde612d02d8aeb3f3dd0f3accd767a2f013cab6e3d486582506fbeb7edb1bda209b333fe7f125fd29f6add6c72b20af320de3537788885fee8b6d76f14b4ad253db2f70a518054bb6f512465e1b6cc154c551d3d59b5bf528eef5a678dbee48e2da74a2803c47295acd6967ea5545f6213456a0f5ead KeeJef","title":"Updating a Loki Name Service Record: Wallet executing is not owner of record)"},{"location":"Messenger/JoinOpenGroupDesktop/","text":"How to join a Session open group (on desktop) \u00b6 Click the \u2018globe\u2019 icon in the sidebar: Click \u2018Join Open Group\u2019: Enter the URL of the open group you\u2019d like to join: Click \u2018Join Open Group\u2019: Enjoy being part of a new community on Session!","title":"Join Open Group on Desktop"},{"location":"Messenger/JoinOpenGroupDesktop/#how-to-join-a-session-open-group-on-desktop","text":"Click the \u2018globe\u2019 icon in the sidebar: Click \u2018Join Open Group\u2019: Enter the URL of the open group you\u2019d like to join: Click \u2018Join Open Group\u2019: Enjoy being part of a new community on Session!","title":"How to join a Session open group (on desktop)"},{"location":"Messenger/JoinOpenGroupMobile/","text":"How to join a Session open group (on mobile) \u00b6 Tap the \u2018globe\u2019 icon. Enter the URL of the open group you\u2019d like to join (be sure to include https:// at the start of the URL!) Tap \u2018next\u2019. Enjoy being part of a new community on Session!","title":"Join Open Group on Mobile"},{"location":"Messenger/JoinOpenGroupMobile/#how-to-join-a-session-open-group-on-mobile","text":"Tap the \u2018globe\u2019 icon. Enter the URL of the open group you\u2019d like to join (be sure to include https:// at the start of the URL!) Tap \u2018next\u2019. Enjoy being part of a new community on Session!","title":"How to join a Session open group (on mobile)"},{"location":"Messenger/LokiNameSystem/","text":"Loki Name System \u00b6 LNS will be released in a limited capacity on the 25th of March alongside the Valiant Vidar hard fork, so it\u2019s important to communicate what you will be able to do with LNS when it launches. How to register a Session/Wallet name. \u00b6 Go to the How to register Session/Wallet name guide . Namespaces \u00b6 The LNS namespace is broken up into two distinct sections, one section is responsible for all lokinet names, referred to as .loki names and the other section is responsible for Wallet and Session usernames. On the initial release we will only be allowing the registration of Wallet and Session usernames. Names \u00b6 Each LNS name can resolve to a Session public key, Wallet address or .loki address. Session and Wallet names are within the same namespace. When purchasing a Session record, the Wallet record is automatically added to your possession. Lokinet names are in their own namespaces. For example, when purchasing \u2018KeeJef\u2019 in the Session namespace, you can assign a Session public key. Additionally you can update the wallet record under a 2nd transaction. So when a user looks up \u2018KeeJef\u2019 they are returned both a Session ID and Wallet address, SessionID: 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Wallet Address: LBMTVEK8WRiC9rmfoKEjyrZSRje6PdiTU6926LjMkGMUdzyApMvXUbH4LswHnLjMjMPLUbDKiL3RCRQe5XFiobWb8jQrApR It is also possible to purchase \u2018KeeJef.loki\u2019 in the Lokinet namespace that is unique from the Session and Wallet namespace. However this will not be available immediately. Depending on which context the name is being used, the application will automatically use the relevant mapping. Rules \u00b6 Each namespace, (Session and Wallet) (Lokinet) have restrictions on the characters allowed in the name. All names are case-insensitive. For Session, the name has to start with a (alphanumeric or underscore), and can have (alphanumeric, hyphens or underscores) in between and must end with a (alphanumeric or underscore). Users may register names with special characters or emojis by using the equivalent Punycode representation. The name must be at least 1 character, and at most- 64 characters long. For Lokinet, the domain has to start with an alphanumeric, and can have (alphanumeric or hyphens) in between. The character before the domain suffix .loki must be alphanumeric followed by the suffix .loki . Users may register names with special characters or emojis by using the equivalent Punycode representation. The domain name must be at most 253 characters long, including the .loki suffix. Time \u00b6 By default all mappings in the Session/Wallet namespace will be preserved forever, this is important to ensure that wallet mappings don't change when a user wants to send money to a name. The .loki namespace will have reregistration periods to deter domain squatting and release names if the keys that registered them are lost. Ownership, Transfer, Updates and management \u00b6 By default names are owned by the wallet address that purchased the name. However names can also be purchased on behalf of another user. Up to 2 wallet addresses may be specified as the owners of a name. This means up to 2 wallets to update and or transfer ownership of the record. Once a domain is owned it can be transferred to another user's Loki wallet by specifying the address of that wallet and paying the standard transaction fee to transfer the ownership. Updates to mappings can be made at any time by the owner, at the cost of the standard transaction fee to include the new mapping in the blockchain. Management of all owned names will be possible through the Loki Desktop Wallet initially however we aim to add functionality to register and manage names to the Session software in the future. Cost \u00b6 Names in the Session/Wallet namespace cost 20 Loki to register, We will try to update this cost per hardfork to target the $5-10 USD range. Privacy \u00b6 It is up to each user to choose what information they map publicly, if you don\u2019t want to map your Session ID or Wallet address to your real world identity you might want to choose a different alias instead of something related to your name. Basic encryption is employed to mask publicity of data on the surface level, however please do not rely on this for critical privacy requirements. See the Loki Name Service technical document for more information. All wallet sub-addresses generated via account new are supported as owners. Technical Documentation \u00b6 Record Encryption/Decryption \u00b6 LNS records stored in the blockchain undergo basic encryption and decryption to deter monitoring of the chain. It does not provide strong guarantees for privacy and should not be relied on for critical privacy usage. At its core, a typical LNS record from the database looks like name_hashed encrypted_value register_height owner backup_owner txid prev_txid register_height more fields (implementation details, see loki_name_system.h) Of which, name_hashed and encrypted_value use some form of encryption or decryption. name_hashed \u00b6 Human readable name is hashed with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Name hash converted to base64 for storage into the sqlite3 database (this provides optimal lexicographic lookup as a key). hash32 = Blake2B(name, key=0) name_hash = Base64Encode(hash32) encrypted_value \u00b6 Generate the secret key for decryption/encryption using the unhashed name with Argon2ID v1.3 and the following parameters as of Valiant Vidar v7.1.X Iterations: 3 Memory: 268_435_456 bytes Salt Length: 0 bytes Key Length: 32 bytes Decrypt/encrypt the value represented in binary with XSalsa20Poly1305 and the following parameters as of Valiant Vidar v7.1.X Nonce: 0 bytes key32 = Argon2ID(iterations=3, memory=268435436, salt=0) encrypted_value = XSalsa20Poly1305Encrypt(value, key32, nonce=0) decrypted_value = XSalsa20Poly1305Decrypt(encrypted_value, key32, nonce=0) Owners \u00b6 In the Loki Name System (LNS), an owner of a record has the ability to update information about the record by making a transaction on the Loki blockchain. Owners are specified when buying a record and in LNS we support 2 types. A standard Ed25519 keypair and a Loki Wallet address. By default, the wallet is configured to assign itself as the owner of the mapping when purchased. Record Updating \u00b6 LNS records can be updated by getting the owner of the record to generate a signature that authorises the protocol to update fields in the record. The following fields can be updated in the record Value Owner Backup Owner Copy the fields to update into a buffer Copy the TXID into the buffer that last updated the record (which can be retrieved by querying the mapping). Hash the buffer with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Sign the hashed buffer If the current owner (or backup owner) is a wallet address, it must be signed with the current owner's (or backup owner's) wallet secret spend key. If the current owner (or backup owner) is a ed25519 key, it must be signed with the current owner's (or backup owner's) ed25519 secret key. // *If value is specified, copy the value to the buffer, otherwise skip. buffer[] = {*binary_value, *owner, *backup_owner, prev_txid} hash32 = Blake2B(buffer, key=0) if (monero) signature = generate_signature(hash32, spend_pkey, spend_skey) else signature = ed25519_signature(hash32, ed25519_skey)","title":"Loki Name System"},{"location":"Messenger/LokiNameSystem/#loki-name-system","text":"LNS will be released in a limited capacity on the 25th of March alongside the Valiant Vidar hard fork, so it\u2019s important to communicate what you will be able to do with LNS when it launches.","title":"Loki Name System"},{"location":"Messenger/LokiNameSystem/#how-to-register-a-sessionwallet-name","text":"Go to the How to register Session/Wallet name guide .","title":"How to register a Session/Wallet name."},{"location":"Messenger/LokiNameSystem/#namespaces","text":"The LNS namespace is broken up into two distinct sections, one section is responsible for all lokinet names, referred to as .loki names and the other section is responsible for Wallet and Session usernames. On the initial release we will only be allowing the registration of Wallet and Session usernames.","title":"Namespaces"},{"location":"Messenger/LokiNameSystem/#names","text":"Each LNS name can resolve to a Session public key, Wallet address or .loki address. Session and Wallet names are within the same namespace. When purchasing a Session record, the Wallet record is automatically added to your possession. Lokinet names are in their own namespaces. For example, when purchasing \u2018KeeJef\u2019 in the Session namespace, you can assign a Session public key. Additionally you can update the wallet record under a 2nd transaction. So when a user looks up \u2018KeeJef\u2019 they are returned both a Session ID and Wallet address, SessionID: 053b6b764388cd6c4d38ae0b3e7492a8ecf0076e270c013bb5693d973045f45254 Wallet Address: LBMTVEK8WRiC9rmfoKEjyrZSRje6PdiTU6926LjMkGMUdzyApMvXUbH4LswHnLjMjMPLUbDKiL3RCRQe5XFiobWb8jQrApR It is also possible to purchase \u2018KeeJef.loki\u2019 in the Lokinet namespace that is unique from the Session and Wallet namespace. However this will not be available immediately. Depending on which context the name is being used, the application will automatically use the relevant mapping.","title":"Names"},{"location":"Messenger/LokiNameSystem/#rules","text":"Each namespace, (Session and Wallet) (Lokinet) have restrictions on the characters allowed in the name. All names are case-insensitive. For Session, the name has to start with a (alphanumeric or underscore), and can have (alphanumeric, hyphens or underscores) in between and must end with a (alphanumeric or underscore). Users may register names with special characters or emojis by using the equivalent Punycode representation. The name must be at least 1 character, and at most- 64 characters long. For Lokinet, the domain has to start with an alphanumeric, and can have (alphanumeric or hyphens) in between. The character before the domain suffix .loki must be alphanumeric followed by the suffix .loki . Users may register names with special characters or emojis by using the equivalent Punycode representation. The domain name must be at most 253 characters long, including the .loki suffix.","title":"Rules"},{"location":"Messenger/LokiNameSystem/#time","text":"By default all mappings in the Session/Wallet namespace will be preserved forever, this is important to ensure that wallet mappings don't change when a user wants to send money to a name. The .loki namespace will have reregistration periods to deter domain squatting and release names if the keys that registered them are lost.","title":"Time"},{"location":"Messenger/LokiNameSystem/#ownership-transfer-updates-and-management","text":"By default names are owned by the wallet address that purchased the name. However names can also be purchased on behalf of another user. Up to 2 wallet addresses may be specified as the owners of a name. This means up to 2 wallets to update and or transfer ownership of the record. Once a domain is owned it can be transferred to another user's Loki wallet by specifying the address of that wallet and paying the standard transaction fee to transfer the ownership. Updates to mappings can be made at any time by the owner, at the cost of the standard transaction fee to include the new mapping in the blockchain. Management of all owned names will be possible through the Loki Desktop Wallet initially however we aim to add functionality to register and manage names to the Session software in the future.","title":"Ownership, Transfer, Updates and management"},{"location":"Messenger/LokiNameSystem/#cost","text":"Names in the Session/Wallet namespace cost 20 Loki to register, We will try to update this cost per hardfork to target the $5-10 USD range.","title":"Cost"},{"location":"Messenger/LokiNameSystem/#privacy","text":"It is up to each user to choose what information they map publicly, if you don\u2019t want to map your Session ID or Wallet address to your real world identity you might want to choose a different alias instead of something related to your name. Basic encryption is employed to mask publicity of data on the surface level, however please do not rely on this for critical privacy requirements. See the Loki Name Service technical document for more information. All wallet sub-addresses generated via account new are supported as owners.","title":"Privacy"},{"location":"Messenger/LokiNameSystem/#technical-documentation","text":"","title":"Technical Documentation"},{"location":"Messenger/LokiNameSystem/#record-encryptiondecryption","text":"LNS records stored in the blockchain undergo basic encryption and decryption to deter monitoring of the chain. It does not provide strong guarantees for privacy and should not be relied on for critical privacy usage. At its core, a typical LNS record from the database looks like name_hashed encrypted_value register_height owner backup_owner txid prev_txid register_height more fields (implementation details, see loki_name_system.h) Of which, name_hashed and encrypted_value use some form of encryption or decryption.","title":"Record Encryption/Decryption"},{"location":"Messenger/LokiNameSystem/#name_hashed","text":"Human readable name is hashed with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Name hash converted to base64 for storage into the sqlite3 database (this provides optimal lexicographic lookup as a key). hash32 = Blake2B(name, key=0) name_hash = Base64Encode(hash32)","title":"name_hashed"},{"location":"Messenger/LokiNameSystem/#encrypted_value","text":"Generate the secret key for decryption/encryption using the unhashed name with Argon2ID v1.3 and the following parameters as of Valiant Vidar v7.1.X Iterations: 3 Memory: 268_435_456 bytes Salt Length: 0 bytes Key Length: 32 bytes Decrypt/encrypt the value represented in binary with XSalsa20Poly1305 and the following parameters as of Valiant Vidar v7.1.X Nonce: 0 bytes key32 = Argon2ID(iterations=3, memory=268435436, salt=0) encrypted_value = XSalsa20Poly1305Encrypt(value, key32, nonce=0) decrypted_value = XSalsa20Poly1305Decrypt(encrypted_value, key32, nonce=0)","title":"encrypted_value"},{"location":"Messenger/LokiNameSystem/#owners","text":"In the Loki Name System (LNS), an owner of a record has the ability to update information about the record by making a transaction on the Loki blockchain. Owners are specified when buying a record and in LNS we support 2 types. A standard Ed25519 keypair and a Loki Wallet address. By default, the wallet is configured to assign itself as the owner of the mapping when purchased.","title":"Owners"},{"location":"Messenger/LokiNameSystem/#record-updating","text":"LNS records can be updated by getting the owner of the record to generate a signature that authorises the protocol to update fields in the record. The following fields can be updated in the record Value Owner Backup Owner Copy the fields to update into a buffer Copy the TXID into the buffer that last updated the record (which can be retrieved by querying the mapping). Hash the buffer with blake2b with the following parameters Key Length: 0 bytes Hash Length: 32 bytes Sign the hashed buffer If the current owner (or backup owner) is a wallet address, it must be signed with the current owner's (or backup owner's) wallet secret spend key. If the current owner (or backup owner) is a ed25519 key, it must be signed with the current owner's (or backup owner's) ed25519 secret key. // *If value is specified, copy the value to the buffer, otherwise skip. buffer[] = {*binary_value, *owner, *backup_owner, prev_txid} hash32 = Blake2B(buffer, key=0) if (monero) signature = generate_signature(hash32, spend_pkey, spend_skey) else signature = ed25519_signature(hash32, ed25519_skey)","title":"Record Updating"},{"location":"Messenger/Session/","text":"Session \u00b6 Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications. Download Links \u00b6 Head over to the Session website to get your Session download Links: Download Register Session Name \u00b6 Head over to the How to register Session/Wallet name guide . Introduction \u00b6 Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Session Docs | Session | Decentralised end-to-end encrypted Private Messenger"},{"location":"Messenger/Session/#session","text":"Session is an open-source, public-key-based secure messaging application which uses a set of decentralised storage servers and an onion routing protocol to send end-to-end encrypted messages with minimal exposure of user metadata. It does this while also providing common features of mainstream messaging applications.","title":"Session"},{"location":"Messenger/Session/#download-links","text":"Head over to the Session website to get your Session download Links: Download","title":"Download Links"},{"location":"Messenger/Session/#register-session-name","text":"Head over to the How to register Session/Wallet name guide .","title":"Register Session Name"},{"location":"Messenger/Session/#introduction","text":"Over the past 10 years, there has been a significant increase in the usage of instant messengers, with the most widely-used messengers each having amassed over 1 billion users. The potential privacy and security shortfalls of many popular messaging applications have been widely discussed. Most current methods of protecting user data privacy are focused on encrypting the contents of messages, an approach which has been relatively successful. This wide deployment of end-to-end encryption (E2EE) does increase user privacy; however, it largely fails to address the growing use of metadata by corporate and state-level actors as a method of tracking user activity. In the context of private messaging, metadata includes the IP addresses and phone numbers of the participants, the time and quantity of sent messages, and the relationship each account has with other accounts. Increasingly, it is the existence and analysis of this metadata that poses a significant privacy risk to journalists, demonstrators and human rights activists. Session is, in large part, a response to this growing risk; it attempts to build robust metadata protection on top of existing protocols, including the Signal protocol, which have already been proven to be effective in providing secure communication channels. Session works to reduce metadata collection in several ways: Firstly, Session does not rely on central servers, instead using a decentralised network of thousands of economically incentivised nodes to perform all core messaging functionality . For those services where decentralisation is impractical, like storage of attachments and hosting of large group chat channels , Session allows users to self-host infrastructure, or rely on built-in encryption and metadata protection to mitigate trust concerns. Secondly, Session ensures that IP addresses cannot be linked to messages sent or received by users. This is accomplished by using an onion routing protocol called onion requests . Thirdly, Session does not ask or require users to provide a phone number or email address when registering a new account. Instead, it uses pseudonymous public-private key pairs as the basis of an account\u2019s identity.","title":"Introduction"},{"location":"Messenger/attachments/","text":"Attachments \u00b6 Although Service Nodes have the ability to store data on behalf of clients, this responsibility only extends so far. Requiring Service nodes to store attachments, which can easily be orders of magnitude larger than messages (and might need to be stored for longer periods of time) would place an undue burden on the Service Node network. With this in mind, a logical solution is for Session to interface with an untrusted centralised server that stores data obliviously. As long as the central server cannot know the contents of files, or who is storing and requesting the files, this system does not cause any metadata leakage. This is achieved by first padding each attachment to fit within a fixed number of constant sizes between 0 and 10 megabytes, then encrypting the attachment with a random symmetric AES key. The sender then uploads the encrypted file using an onion request. In response, the file server provides a link to the piece of content, returned via the onion request path. Once the sender obtains this link, they then send a message to the recipient via an existing pairwise session. This message contains a link to the content, a hash of the content, and the decryption key. The recipient then uses an onion request to pull the encrypted attachment from the centralised file server and decrypt it locally using the decryption key provided by the sender. The recipient also checks the hash against the attachment, ensuring the file has not been modified in transit. By default, all Session clients use a Session file server run by the Loki Foundation for attachment sending and storage. Since attachments are not considered a core feature of Session, this design is in keeping with Session's design principles. The file server is fully open-source, with setup instructions provided so that users are able to set up their own file server. Users are able to specify in the Session client which file server they want to use for attachment sending functionality. This is important both for providing users with choice and control, and ensuring the continued usefulness and functionality of Session if the Loki Foundation were no longer able to maintain the default Session file server.","title":"Attachments"},{"location":"Messenger/attachments/#attachments","text":"Although Service Nodes have the ability to store data on behalf of clients, this responsibility only extends so far. Requiring Service nodes to store attachments, which can easily be orders of magnitude larger than messages (and might need to be stored for longer periods of time) would place an undue burden on the Service Node network. With this in mind, a logical solution is for Session to interface with an untrusted centralised server that stores data obliviously. As long as the central server cannot know the contents of files, or who is storing and requesting the files, this system does not cause any metadata leakage. This is achieved by first padding each attachment to fit within a fixed number of constant sizes between 0 and 10 megabytes, then encrypting the attachment with a random symmetric AES key. The sender then uploads the encrypted file using an onion request. In response, the file server provides a link to the piece of content, returned via the onion request path. Once the sender obtains this link, they then send a message to the recipient via an existing pairwise session. This message contains a link to the content, a hash of the content, and the decryption key. The recipient then uses an onion request to pull the encrypted attachment from the centralised file server and decrypt it locally using the decryption key provided by the sender. The recipient also checks the hash against the attachment, ensuring the file has not been modified in transit. By default, all Session clients use a Session file server run by the Loki Foundation for attachment sending and storage. Since attachments are not considered a core feature of Session, this design is in keeping with Session's design principles. The file server is fully open-source, with setup instructions provided so that users are able to set up their own file server. Users are able to specify in the Session client which file server they want to use for attachment sending functionality. This is important both for providing users with choice and control, and ensuring the continued usefulness and functionality of Session if the Loki Foundation were no longer able to maintain the default Session file server.","title":"Attachments"},{"location":"Messenger/client_side_protection/","text":"Client-Side Protections \u00b6 Secure messaging applications have typically focused their development efforts towards providing protections against network and server level adversaries, which has led to new advances in encryption and metadata protections. However, when interviewing high risk individuals researchers, it has been found that client-side privacy and security protections are some of the most-requested features. High-risk individuals may not be focused on protecting themselves against global adversaries, but instead against a small nation state, or corporate entity. For these individuals, endpoint compromise, device seizure, and forced disclosures are described as the biggest risks. To better mitigate these risks, Session implements a number of client-side protections which allow users to better manage the security of the Session app on their device. Deletion \u00b6 Granular message and data deletion controls are important for users who are likely to have their devices physically sized. Session implements standard features like disappearing messages, which are deleted from sending and receiving clients after being viewed, and the ability to fully wipe all client side stored data. However, Session also features additional ways to manage client side security. Duress Codes \u00b6 Users may set a PIN or pattern lock to access the Session app, which adds additional security on top of any device-level passcodes. As an additional layer of security, users may also specify a duress code, which if entered in lieu of the standard Session app PIN, will wipe Session app data on the device. This is useful in cases where users are forced to unlock their devices and wish for it to appear as if there was never data to begin with. Remote Deletion \u00b6 Remote deletion allows a user to specify a trusted friend and negotiate a shared secret with that friend. Once this secret is generated and stored on the device, the trusted friend can generate a remote deletion message which reveals this prearranged secret. When this message is received by the user\u2019s device, it initiates the immediate destruction of their local database. Pseudonyms High-risk users such as whistleblowers often need to create accounts which are not linked to any real-world physical identifiers (e.g. phone numbers and email addresses). Session account creation only requires generation of a public-private key pair, making it trivial for users to establish multiple pseudonyms without needing to link their account to pieces of information which could be used to identify them. Backup and Restore Account States \u00b6 Border crossings or checkpoints can be an area of significantly increased risk for high-risk users. In these zones, high-risk users may be forced to disclose passwords and surrender devices so device images can be taken. To protect their data, some high-risk individuals have begun implementing a strategy of backing up device and application data, wiping their device to cross a border or pass through a checkpoint, and then restoring that data once it is safe to do so. To ease this process, Session supports encrypted backups to a number of popular cloud services. Backups are encrypted with a symmetric key derived from the user\u2019s Session long-term private key, meaning the user only needs knowledge of their 12 word mnemonic seed (recovery phrase) to recover their account after completing the border or checkpoint crossing.","title":"Client Side Protection"},{"location":"Messenger/client_side_protection/#client-side-protections","text":"Secure messaging applications have typically focused their development efforts towards providing protections against network and server level adversaries, which has led to new advances in encryption and metadata protections. However, when interviewing high risk individuals researchers, it has been found that client-side privacy and security protections are some of the most-requested features. High-risk individuals may not be focused on protecting themselves against global adversaries, but instead against a small nation state, or corporate entity. For these individuals, endpoint compromise, device seizure, and forced disclosures are described as the biggest risks. To better mitigate these risks, Session implements a number of client-side protections which allow users to better manage the security of the Session app on their device.","title":"Client-Side Protections"},{"location":"Messenger/client_side_protection/#deletion","text":"Granular message and data deletion controls are important for users who are likely to have their devices physically sized. Session implements standard features like disappearing messages, which are deleted from sending and receiving clients after being viewed, and the ability to fully wipe all client side stored data. However, Session also features additional ways to manage client side security.","title":"Deletion"},{"location":"Messenger/client_side_protection/#duress-codes","text":"Users may set a PIN or pattern lock to access the Session app, which adds additional security on top of any device-level passcodes. As an additional layer of security, users may also specify a duress code, which if entered in lieu of the standard Session app PIN, will wipe Session app data on the device. This is useful in cases where users are forced to unlock their devices and wish for it to appear as if there was never data to begin with.","title":"Duress Codes"},{"location":"Messenger/client_side_protection/#remote-deletion","text":"Remote deletion allows a user to specify a trusted friend and negotiate a shared secret with that friend. Once this secret is generated and stored on the device, the trusted friend can generate a remote deletion message which reveals this prearranged secret. When this message is received by the user\u2019s device, it initiates the immediate destruction of their local database. Pseudonyms High-risk users such as whistleblowers often need to create accounts which are not linked to any real-world physical identifiers (e.g. phone numbers and email addresses). Session account creation only requires generation of a public-private key pair, making it trivial for users to establish multiple pseudonyms without needing to link their account to pieces of information which could be used to identify them.","title":"Remote Deletion"},{"location":"Messenger/client_side_protection/#backup-and-restore-account-states","text":"Border crossings or checkpoints can be an area of significantly increased risk for high-risk users. In these zones, high-risk users may be forced to disclose passwords and surrender devices so device images can be taken. To protect their data, some high-risk individuals have begun implementing a strategy of backing up device and application data, wiping their device to cross a border or pass through a checkpoint, and then restoring that data once it is safe to do so. To ease this process, Session supports encrypted backups to a number of popular cloud services. Backups are encrypted with a symmetric key derived from the user\u2019s Session long-term private key, meaning the user only needs knowledge of their 12 word mnemonic seed (recovery phrase) to recover their account after completing the border or checkpoint crossing.","title":"Backup and Restore Account States"},{"location":"Messenger/group_chats/","text":"Group Chats \u00b6 Instant messaging applications are increasingly becoming places for communities to gather, rather than simply being used for one-on-one conversations. This has led to widespread use of group chats, channels, and similar functionality in messaging applications. Many of the most popular messaging applications support group chats, but the levels of encryption and privacy provided to users in these group chats is often unclear. Group chats in applications such as Telegram and Facebook Messenger only support transport encryption, rather than end-to-end encryption. Even those applications which do support end-to-end encryption in group chats (e.g. Signal and WhatsApp) still use central servers to store and disseminate messages. There are two key areas to focus on when considering the deployment of encrypted group chats in Session. Scaling \u00b6 There are two main approaches to sending messages in a group chat: server-side fanout and client-side fanout. The choice of method can have a significant impact on the scalability of the group chat. In client-side fanout, the client individually pushes their message to each recipient device or swarm. Client-side fanout is preferable in some cases since it can be done in peer-to-peer networks and does not require the establishment of a central server. However, client-side fanout can prove burdensome on client bandwidth and CPU usage as the number of group members increase \u2014 a factor which proves particularly problematic for mobile devices. Figure 1: Client sends message using client-side fanout. In server-side fanout, the client typically sends their message to a server, from which the message is pushed out to each of the other clients (the other clients may also fetch the message from the server at a later point in time), which is more efficient for larger groups. Figure 2: Client sends message using server-side fanout: Here, the client sends the message to the server (solid red line) and the server then distributes the messages to clients (dotted red lines) End-to-end Encryption \u00b6 Another factor which impacts group chat scalability is the choice of how to implement end-to-end encryption. The most naive solution to building group chats in Session would be to simply leverage the existing pairwise sessions we can create for one-on-one conversations. To send a message to a group chat, a pairwise session would be started with every member of the group, and each message would be individually encrypted for each participant. This provides the group chat with the same guarantees possessed by standard pairwise communications using the Signal protocol: perfect forward secrecy and deniable authentication. However, this would come at the cost of requiring the payload to be encrypted and stored N times, where N is the number of members in the group. This process could become burdensome for low-powered clients participating in large group chats. One way to improve group chats is to adopt the \"Sender Keys\" system used by WhatsApp. This system involves a set of keys (a Chain Key and a Signature Key) that each client generates for each of its groups. These Sender Keys are shared between all group members in a traditional pairwise manner using the Signal protocol. When a client needs to send a message to the group, it derives a message encryption key using its Chain Key and encrypts the message only once. In Session, this would allow only having to generate proof of work exactly once per message, irrespective of the number of members in a group. The same ciphertext can then be decrypted by all other group members, as they can generate the same message key from the senders' chain key. Note that all future keys can be generated this way by all group members, so no further sharing of keys is necessary. However, all Sender Keys in the group will need to be updated whenever a group member leaves or is kicked from the group to ensure that they won't be able to read future messages. Additionally, this approach has the downside of losing the \u201cself healing\u201d property of the traditional Signal protocol provided in pairwise sessions. The Sender Keys scheme is effective in small- to medium-sized group chats where the membership set changes infrequently. However, it can be impractical in larger groups, where users frequently leave (or are kicked from) the chat as all Sender Keys must be updated and redistributed in each such event. Further improvements to the Sender Keys scheme have been proposed in the draft MLS specification (discussed in Future Work below). Other Considerations \u00b6 Group Size \u00b6 It may be possible to create large encrypted groups that scale well even when members are added and removed frequently. However, the reality of large groups is that as more members are added to the group, it becomes increasingly likely that members will leak or otherwise share the contents of the conversation. Identifying and removing a malicious or compromised group member in a very large group is difficult, and thus, perfect forward secrecy and deniability would be violated in such cases, unless malicious users could be identified and removed. Proof of Work \u00b6 A small proof of work must be produced for each new message which is sent offline and stored in a swarm (see Spam below). In a case where many group members are offline at the same time, the sender must calculate many such proofs of work before their message can be delivered to all members of the chat, this quickly becomes taxing on mobile devices. Metadata Protection \u00b6 Information about a group chat, including the public keys of members, administrators, and the IP addresses of users, should be kept private by participants, as public availability of information about the relationships between public keys significantly reduces privacy Group Type Comparisons \u00b6 With the above considerations in mind, Session deploys two different schemes for the encryption and scaling of group chats, with scheme selection based on group size. Closed Groups 3 - 500 Members \u00b6 To initialise a closed group chat, a user selects a number of users from their contacts list. The user's client sends a control message through a pairwise channel to the selected users. This control message communicates the group name, group members, group avatar, and other relevant data about the group. If the group chat includes users who have not previously communicated with each other, sessions are established between these users in the background. Using these pairwise channels, the group derives shared ephemeral encryption and signing keys. This ensures messages only need to be encrypted once for the entire group, as per the Sender Keys scheme detailed above. Instead of communicating these encrypted messages to each user in the group individually, the group chooses a random swarm to store non-pairwise messages. This ensures messages are only stored on a single swarm, regardless of group size. Onion requests are used for transmitting messages to and from the shared swarm, and also used any time pairwise communication is required. Closed Group Administration \u00b6 The creator of a closed group becomes the administrator of that group. All users added to the group have rights to add new members, but users can only be kicked from the group by the administrator. This information is shared through pairwise channels when the group is created, and sent via a pairwise channel to new members when they join the group. Open Groups \u00b6 Large closed groups run into significant scaling issues when members leave the group, as keys must be re-derived and redistributed to the entire group \u2014 an inefficient process when there may be hundreds or thousands of members. Additionally, as previously addressed, the usefulness of end-to-end encryption in very large groups is unclear, since a single malicious group member or compromised device is catastrophic to group privacy, and in large groups this is extremely difficult to protect against, regardless of the degree of encryption deployed. In Session, once group membership reaches the upper bound for closed groups, the administrator is encouraged to convert the group into an open group. open groups revert to transport-only encryption, which protects users against network adversaries but provides comparably weak protection against server-side attacks. To balance the risk of such attacks, Session's open groups do not use the Service Node architecture. Open groups instead require group administrators to operate their own server, or arrange for a channel to be created on an existing open group server host. The software required to do this is open-source, and a reference implementation is provided. All messages and attachments stored on open group servers are fetched and posted through onion requests using the IP address or domain name of the open group host server, preserving network-layer anonymity for participants. Open Group Administration \u00b6 Administration of open groups is comparably more complex than that of closed groups. The open group server operator is the original administrator, and they are able to add new administrators. All administrators have the right to delete messages from the server. Joining rights to open groups falls into one of two categories: whitelist-based groups and blacklist-based groups. Whitelist-based groups require each user's public key to be preapproved (added to the whitelist) by an administrator, and users must be invited before being able to join the open group. Blacklist-based groups can be joined by any user who knows the domain/IP address of the group, but users can be banned if an administrator adds their public key to a list of banned public keys (the blacklist).","title":"Group Chats"},{"location":"Messenger/group_chats/#group-chats","text":"Instant messaging applications are increasingly becoming places for communities to gather, rather than simply being used for one-on-one conversations. This has led to widespread use of group chats, channels, and similar functionality in messaging applications. Many of the most popular messaging applications support group chats, but the levels of encryption and privacy provided to users in these group chats is often unclear. Group chats in applications such as Telegram and Facebook Messenger only support transport encryption, rather than end-to-end encryption. Even those applications which do support end-to-end encryption in group chats (e.g. Signal and WhatsApp) still use central servers to store and disseminate messages. There are two key areas to focus on when considering the deployment of encrypted group chats in Session.","title":"Group Chats"},{"location":"Messenger/group_chats/#scaling","text":"There are two main approaches to sending messages in a group chat: server-side fanout and client-side fanout. The choice of method can have a significant impact on the scalability of the group chat. In client-side fanout, the client individually pushes their message to each recipient device or swarm. Client-side fanout is preferable in some cases since it can be done in peer-to-peer networks and does not require the establishment of a central server. However, client-side fanout can prove burdensome on client bandwidth and CPU usage as the number of group members increase \u2014 a factor which proves particularly problematic for mobile devices. Figure 1: Client sends message using client-side fanout. In server-side fanout, the client typically sends their message to a server, from which the message is pushed out to each of the other clients (the other clients may also fetch the message from the server at a later point in time), which is more efficient for larger groups. Figure 2: Client sends message using server-side fanout: Here, the client sends the message to the server (solid red line) and the server then distributes the messages to clients (dotted red lines)","title":"Scaling"},{"location":"Messenger/group_chats/#end-to-end-encryption","text":"Another factor which impacts group chat scalability is the choice of how to implement end-to-end encryption. The most naive solution to building group chats in Session would be to simply leverage the existing pairwise sessions we can create for one-on-one conversations. To send a message to a group chat, a pairwise session would be started with every member of the group, and each message would be individually encrypted for each participant. This provides the group chat with the same guarantees possessed by standard pairwise communications using the Signal protocol: perfect forward secrecy and deniable authentication. However, this would come at the cost of requiring the payload to be encrypted and stored N times, where N is the number of members in the group. This process could become burdensome for low-powered clients participating in large group chats. One way to improve group chats is to adopt the \"Sender Keys\" system used by WhatsApp. This system involves a set of keys (a Chain Key and a Signature Key) that each client generates for each of its groups. These Sender Keys are shared between all group members in a traditional pairwise manner using the Signal protocol. When a client needs to send a message to the group, it derives a message encryption key using its Chain Key and encrypts the message only once. In Session, this would allow only having to generate proof of work exactly once per message, irrespective of the number of members in a group. The same ciphertext can then be decrypted by all other group members, as they can generate the same message key from the senders' chain key. Note that all future keys can be generated this way by all group members, so no further sharing of keys is necessary. However, all Sender Keys in the group will need to be updated whenever a group member leaves or is kicked from the group to ensure that they won't be able to read future messages. Additionally, this approach has the downside of losing the \u201cself healing\u201d property of the traditional Signal protocol provided in pairwise sessions. The Sender Keys scheme is effective in small- to medium-sized group chats where the membership set changes infrequently. However, it can be impractical in larger groups, where users frequently leave (or are kicked from) the chat as all Sender Keys must be updated and redistributed in each such event. Further improvements to the Sender Keys scheme have been proposed in the draft MLS specification (discussed in Future Work below).","title":"End-to-end Encryption"},{"location":"Messenger/group_chats/#other-considerations","text":"","title":"Other Considerations"},{"location":"Messenger/group_chats/#group-size","text":"It may be possible to create large encrypted groups that scale well even when members are added and removed frequently. However, the reality of large groups is that as more members are added to the group, it becomes increasingly likely that members will leak or otherwise share the contents of the conversation. Identifying and removing a malicious or compromised group member in a very large group is difficult, and thus, perfect forward secrecy and deniability would be violated in such cases, unless malicious users could be identified and removed.","title":"Group Size"},{"location":"Messenger/group_chats/#proof-of-work","text":"A small proof of work must be produced for each new message which is sent offline and stored in a swarm (see Spam below). In a case where many group members are offline at the same time, the sender must calculate many such proofs of work before their message can be delivered to all members of the chat, this quickly becomes taxing on mobile devices.","title":"Proof of Work"},{"location":"Messenger/group_chats/#metadata-protection","text":"Information about a group chat, including the public keys of members, administrators, and the IP addresses of users, should be kept private by participants, as public availability of information about the relationships between public keys significantly reduces privacy","title":"Metadata Protection"},{"location":"Messenger/group_chats/#group-type-comparisons","text":"With the above considerations in mind, Session deploys two different schemes for the encryption and scaling of group chats, with scheme selection based on group size.","title":"Group Type Comparisons"},{"location":"Messenger/group_chats/#closed-groups-3-500-members","text":"To initialise a closed group chat, a user selects a number of users from their contacts list. The user's client sends a control message through a pairwise channel to the selected users. This control message communicates the group name, group members, group avatar, and other relevant data about the group. If the group chat includes users who have not previously communicated with each other, sessions are established between these users in the background. Using these pairwise channels, the group derives shared ephemeral encryption and signing keys. This ensures messages only need to be encrypted once for the entire group, as per the Sender Keys scheme detailed above. Instead of communicating these encrypted messages to each user in the group individually, the group chooses a random swarm to store non-pairwise messages. This ensures messages are only stored on a single swarm, regardless of group size. Onion requests are used for transmitting messages to and from the shared swarm, and also used any time pairwise communication is required.","title":"Closed Groups 3 - 500 Members"},{"location":"Messenger/group_chats/#closed-group-administration","text":"The creator of a closed group becomes the administrator of that group. All users added to the group have rights to add new members, but users can only be kicked from the group by the administrator. This information is shared through pairwise channels when the group is created, and sent via a pairwise channel to new members when they join the group.","title":"Closed Group Administration"},{"location":"Messenger/group_chats/#open-groups","text":"Large closed groups run into significant scaling issues when members leave the group, as keys must be re-derived and redistributed to the entire group \u2014 an inefficient process when there may be hundreds or thousands of members. Additionally, as previously addressed, the usefulness of end-to-end encryption in very large groups is unclear, since a single malicious group member or compromised device is catastrophic to group privacy, and in large groups this is extremely difficult to protect against, regardless of the degree of encryption deployed. In Session, once group membership reaches the upper bound for closed groups, the administrator is encouraged to convert the group into an open group. open groups revert to transport-only encryption, which protects users against network adversaries but provides comparably weak protection against server-side attacks. To balance the risk of such attacks, Session's open groups do not use the Service Node architecture. Open groups instead require group administrators to operate their own server, or arrange for a channel to be created on an existing open group server host. The software required to do this is open-source, and a reference implementation is provided. All messages and attachments stored on open group servers are fetched and posted through onion requests using the IP address or domain name of the open group host server, preserving network-layer anonymity for participants.","title":"Open Groups"},{"location":"Messenger/group_chats/#open-group-administration","text":"Administration of open groups is comparably more complex than that of closed groups. The open group server operator is the original administrator, and they are able to add new administrators. All administrators have the right to delete messages from the server. Joining rights to open groups falls into one of two categories: whitelist-based groups and blacklist-based groups. Whitelist-based groups require each user's public key to be preapproved (added to the whitelist) by an administrator, and users must be invited before being able to join the open group. Blacklist-based groups can be joined by any user who knows the domain/IP address of the group, but users can be banned if an administrator adds their public key to a list of banned public keys (the blacklist).","title":"Open Group Administration"},{"location":"Messenger/infrastructure/","text":"Infrastructure \u00b6 Foundations \u00b6 At its core, Session is built on the Loki Service Node network, so it is important to understand what this network is, how it functions, and what properties Session derives from it. Service Nodes \u00b6 Many projects have attempted to establish decentralised permissionless networks. These projects have often found themselves struggling with a \u2018tragedy of the commons\u2019 of sorts, wherein public servers, required for the operation of the network, are under-resourced and overused. This inadvertently causes the network to provide poor service to users, which discourages further use or expansion of the network. Conversely, those projects which are able to create large, public permissionless networks find themselves constantly facing questions about the parties that contribute to running that infrastructure. This can be especially damaging when the operation of that infrastructure can adversely affect the privacy, security, or user experience of an application. For example, the Tor network faces constant questions about evidence of Sybil attacks from unknown parties attempting to run large sections of of the public routing network, which could be used to deanonymise users . Session seeks to sidestep these questions by using a different type of public access network: a staked routing and storage network called the Loki Service Node network. This network is based on the Loki blockchain, which itself is based on the Cryptonote protocol. Through the integration of a blockchain network, Session creates a financial precondition for anyone wishing to host a server on the network, and thus participate in Session\u2019s message storage and routing architecture. Authorisation for a server to operate on the network is attained through the server operator conducting a special staking transaction, which requires that an operator provably lock an amount of Loki cryptocurrency assigned to their node (approximately 18,550 Loki coins; equivalent USD 7,420 dollars as of 10/02/2020). This staking system provides a defense against Sybil attacks by limiting attackers based on the amount of financial resources they have available. The staking system also achieves two other goals which further reduce the likelihood of a Sybil attack. Firstly, the need for attackers to buy or control Loki to run Service Nodes creates a feedback loop of increasing prices to run large portions of the network. That is, as the attacker buys or acquires more Loki and locks it, removing it from the circulating supply, the supply of Loki is decreased and the demand from the attacker must be sustained. This causes the price of any remaining Loki to increase, furthering the feedback loop of increasing prices. Secondly, the staking system binds an attacker to their stake, meaning if they are found to be performing active attacks, the underlying value of their stake can sharply decline as users lose trust in the network, or could be destroyed or locked by the network, in any case increasing the attackers sunken costs. The other main advantage of a staked blockchain network is that Service Nodes earn rewards for the work they do. Service Nodes are paid a portion of the block reward minted upon the creation of each new block. This system makes Session distinct from altruistic networks like Tor and I2P and instead provides an incentive linked directly with the performance of a Service Node. Honest node behaviour and the provision of a minimum standard of operation is ensured through a consensus-based testing suite. Misbehaving nodes face the threat of having their staked capital locked, while the previously-mentioned cryptocurrency rewards function as the positive incentive for nodes to behave honestly and provide at least the minimum standard of service to the network. Onion Requests \u00b6 The other foundational component of Session is an onion routing protocol, referred to as onion requests, which enables Session clients to obfuscate their IP addresses by creating a 3-hop randomised path through the Service Node network. Onion requests use a simple onion routing protocol which successively encrypts each request for each of the three hops, ensuring: the first Service Node only knows the IP address of the client and the IP address of the middle Service Node, the middle Service Node only knows the IP address of the first and last Service Nodes, and the last Service Node only knows the IP address of the middle Service Node and the final destination IP address for the request. Each Session client establishes a path on startup, and once established, all requests for messages, attachments and meta information are sent through this path. Session clients establish a path by selecting three random nodes from their Service Node list (see bootstrapping), which contains each Service Node\u2019s IP address, storage server port and X25519 key. Clients use this information to create an onion, with each layer being encrypted with the X25519 key of its respective service node. This onion is sent to the first Service Node\u2019s storage server; this Service Node then decrypts its layer of the onion. When a Service Node unwraps a layer, the destination key for the next node is revealed. The first Service Node decrypts its layer and initialises a ZMQ connection with the specified downstream node. When the onion reaches the final node in the path, that node sends a path build success message backwards through the path, which indicates a successful path built upon its receipt by the client. Upon receiving the path build success message, the client will encrypt their messages with the X25519 keys of the final destination, be that a Service Node, file server, open group server, or client. The client also includes an ephemeral X25519 key in their request. When the destination server or client receives the request, they decrypt it and generate a response. This response is then sent back down the previously-established path, encrypted for the initial sender\u2019s (the client\u2019s) ephemeral key, so that the client can decrypt this response upon receiving it. Building on Foundations \u00b6 Onion requests provide a straightforward anonymous networking layer, and the Service Node network provides an incentivised, self-regulating network of remote servers which provide bandwidth and storage space. A number of services are built on top of this foundation in order to give Session features commonly expected of modern messaging applications. Storage Message storage is an essential feature for any chat application aiming to provide a good user experience. When a user sends a message, they expect the recipient to receive that message even if they turn off their device after the message has been sent. Users also expect the user on the other end to receive the message when their device wakes up from an offline state. Apps that run on decentralised networks typically cannot provide this experience, because of the lack of incentive structures and, consequently, the ephemeral nature of clients and servers on such a network. Session is able to provide message storage through the incentivised Service Node network and its usage of swarms. Swarms \u00b6 Although the Loki blockchain incentivises correct Service Node behaviour through rewards and punishments, these incentive models cannot prevent nodes going offline unexpectedly due to operator choice, software bugs, or data center outages. Therefore, for redundancy, a secondary logical data storage layer must be built on top of the Service Node network to ensure reliable message storage and retrieval. This secondary logical layer is provided by replicating messages across small groupings of Service Nodes called swarms. The swarm a Service Node initially joins is determined at the time of that Service Node\u2019s registration, with the Service Node having minimal influence over which swarm it joins. This protects against swarms being entirely made up of malicious or non-performant nodes, which is important to maintain the network\u2019s self-regulating properties. Composition of each swarm inevitably changes as the networks evolves: some nodes leave the network and the newly registered nodes take their place. If a swarm loses a large number of nodes it may additionally \"steal\" a node from some other, larger swarm. In the unlikely event that the network has no swarms to steal from (i.e., every swarm is at Nmin=5 nodes), the \u2018starving\u2019 swarm (a swarm with fewer than Nmin nodes) will be dissolved and its nodes will be redistributed among the remaining swarms. Conversely, when a large number of nodes enter the network that would oversaturate existing swarms (i.e., every swarm is already at max capacity Nmax=10), a new swarm is created from a random selection of Ntarget=7 excess nodes. Note that Nmin < Ntarget < Nmax to ensure that a newly generated swarm doesn\u2019t get dissolved shortly after and that there is still room for growth. The outcome of this algorithm is the creation and, when necessary, rebalancing of swarms of around Nmin\u2060\u2013Nmax Service Nodes which store and serve Session clients\u2019 messages. The goal of the swarm algorithm is to ensure that no swarm is controlled by a single entity and that the network is resilient enough to handle both small and large scale events where Service Nodes are no longer contactable, ensuring data integrity and privacy in both cases. The following set of simple rules ensure that Service Nodes within swarms remain synchronised as the composition of swarms changes: When a node joins a new swarm, existing swarm members recognise this and push the swarm\u2019s data records to the new member. When a node leaves a swarm, its existing records can be safely erased, with the exception of when the node is migrating from a dissolving swarm. In this case, the migrating node determines the swarms responsible for its records and distributes them accordingly. Identity and Long-Term Keys \u00b6 The majority of popular messaging applications require the user to register with an email or phone number in order to use the service. This provides some advantages, including account verification, for purposes of spam protection, and social network discoverability. However, such requirements also create some major privacy and security issues for users. The use of a phone number as the basis for ownership of an identity key/long-term key pair weakens security against user accounts being compromised, such as in the cases of popular applications like Signal and WhatsApp. This weakness primarily stems from the fact that phone numbers are managed by centralised service providers (i.e. telecommunications service providers) who can circumvent user control, allowing these providers to assume direct control of specific users\u2019 numbers. Widespread legislation already exists to compel service providers to take this kind of action. Additionally, methods such as SIM swapping attacks, service provider hacking, and phone number recycling can all be exploited by lower-level actors . Signal and Whatsapp put forward varying degrees of protection against these types of attacks. Signal and WhatsApp both send a 'Safety numbers have changed' warning to a user's contacts if identity keys are changed. In practice, however, users rarely verify these details out-of-band . Both Signal and WhatsApp also allow users to set a \"registration PIN lock\" . This protection means that an attacker (including a service provider or state-level actor) needs access to both the phone number and the registration PIN code to modify identity keys. However, this feature is off by default, difficult to find in the settings menu, and automatically disabled after periods of user inactivity. These factors all significantly reduce the efficacy of registration PIN locks as a protective measure against the security risks of phone number-linked accounts. Using phone numbers as the basis for account registration also greatly weakens the privacy achievable by an average user. In most countries, users must provide personally identifiable information such as a passport, drivers' license or identity card to obtain a phone number \u2014 permanently mapping users\u2019 identities to their phone numbers.These identity mappings are kept in private databases that can be queried by governments or the service providers that own them. There are also a number of web scrapers and indexers that automatically scrape phone numbers associated with individuals. These scrapers may target sources such as leaked databases, public social media profiles, and business phone numbers to link people to their phone numbers. Since the only method of initiating contact with a user in Signal, WhatsApp, or similar application is to know the user\u2019s phone number, this immediately strips away user anonymity \u2014 a significant concern for whistleblowers, activists, protestors and other such users. Account systems based on phone numbers also limit the potential for the establishment of multiple identities by a single user. These systems also prevent high-risk users without access to a phone number from accessing these services. Session does not use email addresses or phone numbers as the basis of its account system. Instead, user identity is established through the generation of X25519 public-private key pairs. These key pairs are not required to be linked with any other identifier, and new key pairs can be generated on-device in seconds. This means that each key pair (and thus, each account) is pseudonymous, unless intentionally linked with an individual identity by the user through out-of-band activity. Restoration \u00b6 Because Session does not have a central server to keep records of user identities, the commonly expected user experience of being able to recover an account using a username and password is not possible. Instead, users are prompted to write down their long-term private key (represented as a mnemonic seed, referred to within Session as a recovery phrase) upon account generation. A user can use this backup key to recover their account if their device is lost or destroyed, and the user's contacts will be able to continue contacting that same user account, rather than having to re-initiate contact with a new key.","title":"Infrastructure"},{"location":"Messenger/infrastructure/#infrastructure","text":"","title":"Infrastructure"},{"location":"Messenger/infrastructure/#foundations","text":"At its core, Session is built on the Loki Service Node network, so it is important to understand what this network is, how it functions, and what properties Session derives from it.","title":"Foundations"},{"location":"Messenger/infrastructure/#service-nodes","text":"Many projects have attempted to establish decentralised permissionless networks. These projects have often found themselves struggling with a \u2018tragedy of the commons\u2019 of sorts, wherein public servers, required for the operation of the network, are under-resourced and overused. This inadvertently causes the network to provide poor service to users, which discourages further use or expansion of the network. Conversely, those projects which are able to create large, public permissionless networks find themselves constantly facing questions about the parties that contribute to running that infrastructure. This can be especially damaging when the operation of that infrastructure can adversely affect the privacy, security, or user experience of an application. For example, the Tor network faces constant questions about evidence of Sybil attacks from unknown parties attempting to run large sections of of the public routing network, which could be used to deanonymise users . Session seeks to sidestep these questions by using a different type of public access network: a staked routing and storage network called the Loki Service Node network. This network is based on the Loki blockchain, which itself is based on the Cryptonote protocol. Through the integration of a blockchain network, Session creates a financial precondition for anyone wishing to host a server on the network, and thus participate in Session\u2019s message storage and routing architecture. Authorisation for a server to operate on the network is attained through the server operator conducting a special staking transaction, which requires that an operator provably lock an amount of Loki cryptocurrency assigned to their node (approximately 18,550 Loki coins; equivalent USD 7,420 dollars as of 10/02/2020). This staking system provides a defense against Sybil attacks by limiting attackers based on the amount of financial resources they have available. The staking system also achieves two other goals which further reduce the likelihood of a Sybil attack. Firstly, the need for attackers to buy or control Loki to run Service Nodes creates a feedback loop of increasing prices to run large portions of the network. That is, as the attacker buys or acquires more Loki and locks it, removing it from the circulating supply, the supply of Loki is decreased and the demand from the attacker must be sustained. This causes the price of any remaining Loki to increase, furthering the feedback loop of increasing prices. Secondly, the staking system binds an attacker to their stake, meaning if they are found to be performing active attacks, the underlying value of their stake can sharply decline as users lose trust in the network, or could be destroyed or locked by the network, in any case increasing the attackers sunken costs. The other main advantage of a staked blockchain network is that Service Nodes earn rewards for the work they do. Service Nodes are paid a portion of the block reward minted upon the creation of each new block. This system makes Session distinct from altruistic networks like Tor and I2P and instead provides an incentive linked directly with the performance of a Service Node. Honest node behaviour and the provision of a minimum standard of operation is ensured through a consensus-based testing suite. Misbehaving nodes face the threat of having their staked capital locked, while the previously-mentioned cryptocurrency rewards function as the positive incentive for nodes to behave honestly and provide at least the minimum standard of service to the network.","title":"Service Nodes"},{"location":"Messenger/infrastructure/#onion-requests","text":"The other foundational component of Session is an onion routing protocol, referred to as onion requests, which enables Session clients to obfuscate their IP addresses by creating a 3-hop randomised path through the Service Node network. Onion requests use a simple onion routing protocol which successively encrypts each request for each of the three hops, ensuring: the first Service Node only knows the IP address of the client and the IP address of the middle Service Node, the middle Service Node only knows the IP address of the first and last Service Nodes, and the last Service Node only knows the IP address of the middle Service Node and the final destination IP address for the request. Each Session client establishes a path on startup, and once established, all requests for messages, attachments and meta information are sent through this path. Session clients establish a path by selecting three random nodes from their Service Node list (see bootstrapping), which contains each Service Node\u2019s IP address, storage server port and X25519 key. Clients use this information to create an onion, with each layer being encrypted with the X25519 key of its respective service node. This onion is sent to the first Service Node\u2019s storage server; this Service Node then decrypts its layer of the onion. When a Service Node unwraps a layer, the destination key for the next node is revealed. The first Service Node decrypts its layer and initialises a ZMQ connection with the specified downstream node. When the onion reaches the final node in the path, that node sends a path build success message backwards through the path, which indicates a successful path built upon its receipt by the client. Upon receiving the path build success message, the client will encrypt their messages with the X25519 keys of the final destination, be that a Service Node, file server, open group server, or client. The client also includes an ephemeral X25519 key in their request. When the destination server or client receives the request, they decrypt it and generate a response. This response is then sent back down the previously-established path, encrypted for the initial sender\u2019s (the client\u2019s) ephemeral key, so that the client can decrypt this response upon receiving it.","title":"Onion Requests"},{"location":"Messenger/infrastructure/#building-on-foundations","text":"Onion requests provide a straightforward anonymous networking layer, and the Service Node network provides an incentivised, self-regulating network of remote servers which provide bandwidth and storage space. A number of services are built on top of this foundation in order to give Session features commonly expected of modern messaging applications. Storage Message storage is an essential feature for any chat application aiming to provide a good user experience. When a user sends a message, they expect the recipient to receive that message even if they turn off their device after the message has been sent. Users also expect the user on the other end to receive the message when their device wakes up from an offline state. Apps that run on decentralised networks typically cannot provide this experience, because of the lack of incentive structures and, consequently, the ephemeral nature of clients and servers on such a network. Session is able to provide message storage through the incentivised Service Node network and its usage of swarms.","title":"Building on Foundations"},{"location":"Messenger/infrastructure/#swarms","text":"Although the Loki blockchain incentivises correct Service Node behaviour through rewards and punishments, these incentive models cannot prevent nodes going offline unexpectedly due to operator choice, software bugs, or data center outages. Therefore, for redundancy, a secondary logical data storage layer must be built on top of the Service Node network to ensure reliable message storage and retrieval. This secondary logical layer is provided by replicating messages across small groupings of Service Nodes called swarms. The swarm a Service Node initially joins is determined at the time of that Service Node\u2019s registration, with the Service Node having minimal influence over which swarm it joins. This protects against swarms being entirely made up of malicious or non-performant nodes, which is important to maintain the network\u2019s self-regulating properties. Composition of each swarm inevitably changes as the networks evolves: some nodes leave the network and the newly registered nodes take their place. If a swarm loses a large number of nodes it may additionally \"steal\" a node from some other, larger swarm. In the unlikely event that the network has no swarms to steal from (i.e., every swarm is at Nmin=5 nodes), the \u2018starving\u2019 swarm (a swarm with fewer than Nmin nodes) will be dissolved and its nodes will be redistributed among the remaining swarms. Conversely, when a large number of nodes enter the network that would oversaturate existing swarms (i.e., every swarm is already at max capacity Nmax=10), a new swarm is created from a random selection of Ntarget=7 excess nodes. Note that Nmin < Ntarget < Nmax to ensure that a newly generated swarm doesn\u2019t get dissolved shortly after and that there is still room for growth. The outcome of this algorithm is the creation and, when necessary, rebalancing of swarms of around Nmin\u2060\u2013Nmax Service Nodes which store and serve Session clients\u2019 messages. The goal of the swarm algorithm is to ensure that no swarm is controlled by a single entity and that the network is resilient enough to handle both small and large scale events where Service Nodes are no longer contactable, ensuring data integrity and privacy in both cases. The following set of simple rules ensure that Service Nodes within swarms remain synchronised as the composition of swarms changes: When a node joins a new swarm, existing swarm members recognise this and push the swarm\u2019s data records to the new member. When a node leaves a swarm, its existing records can be safely erased, with the exception of when the node is migrating from a dissolving swarm. In this case, the migrating node determines the swarms responsible for its records and distributes them accordingly.","title":"Swarms"},{"location":"Messenger/infrastructure/#identity-and-long-term-keys","text":"The majority of popular messaging applications require the user to register with an email or phone number in order to use the service. This provides some advantages, including account verification, for purposes of spam protection, and social network discoverability. However, such requirements also create some major privacy and security issues for users. The use of a phone number as the basis for ownership of an identity key/long-term key pair weakens security against user accounts being compromised, such as in the cases of popular applications like Signal and WhatsApp. This weakness primarily stems from the fact that phone numbers are managed by centralised service providers (i.e. telecommunications service providers) who can circumvent user control, allowing these providers to assume direct control of specific users\u2019 numbers. Widespread legislation already exists to compel service providers to take this kind of action. Additionally, methods such as SIM swapping attacks, service provider hacking, and phone number recycling can all be exploited by lower-level actors . Signal and Whatsapp put forward varying degrees of protection against these types of attacks. Signal and WhatsApp both send a 'Safety numbers have changed' warning to a user's contacts if identity keys are changed. In practice, however, users rarely verify these details out-of-band . Both Signal and WhatsApp also allow users to set a \"registration PIN lock\" . This protection means that an attacker (including a service provider or state-level actor) needs access to both the phone number and the registration PIN code to modify identity keys. However, this feature is off by default, difficult to find in the settings menu, and automatically disabled after periods of user inactivity. These factors all significantly reduce the efficacy of registration PIN locks as a protective measure against the security risks of phone number-linked accounts. Using phone numbers as the basis for account registration also greatly weakens the privacy achievable by an average user. In most countries, users must provide personally identifiable information such as a passport, drivers' license or identity card to obtain a phone number \u2014 permanently mapping users\u2019 identities to their phone numbers.These identity mappings are kept in private databases that can be queried by governments or the service providers that own them. There are also a number of web scrapers and indexers that automatically scrape phone numbers associated with individuals. These scrapers may target sources such as leaked databases, public social media profiles, and business phone numbers to link people to their phone numbers. Since the only method of initiating contact with a user in Signal, WhatsApp, or similar application is to know the user\u2019s phone number, this immediately strips away user anonymity \u2014 a significant concern for whistleblowers, activists, protestors and other such users. Account systems based on phone numbers also limit the potential for the establishment of multiple identities by a single user. These systems also prevent high-risk users without access to a phone number from accessing these services. Session does not use email addresses or phone numbers as the basis of its account system. Instead, user identity is established through the generation of X25519 public-private key pairs. These key pairs are not required to be linked with any other identifier, and new key pairs can be generated on-device in seconds. This means that each key pair (and thus, each account) is pseudonymous, unless intentionally linked with an individual identity by the user through out-of-band activity.","title":"Identity and Long-Term Keys"},{"location":"Messenger/infrastructure/#restoration","text":"Because Session does not have a central server to keep records of user identities, the commonly expected user experience of being able to recover an account using a username and password is not possible. Instead, users are prompted to write down their long-term private key (represented as a mnemonic seed, referred to within Session as a recovery phrase) upon account generation. A user can use this backup key to recover their account if their device is lost or destroyed, and the user's contacts will be able to continue contacting that same user account, rather than having to re-initiate contact with a new key.","title":"Restoration"},{"location":"Messenger/message_routing/","text":"Message Routing \u00b6 Session follows one of two distinct cases for message routing, depending on the availability of participating clients: Asynchronous (Offline) Routing \u00b6 By default, or when either of the participating clients' statuses is determined as offline (see Synchronous Routing for how client status is determined), Session will use asynchronous routing. In asynchronous routing, the sender determines the recipient's swarm by obtaining the deterministic mapping between the recipient's long-term public key and the currently registered Service Nodes. This information is initially requested from a random Service Node by the sender and updated whenever the client gets an error message in the response that indicates a missing swarm. Once this mapping is determined, the sender creates the message protobuf and packs the protobuf in an envelope with the information to be processed by Service Nodes: the long-term public key of the recipient, a timestamp, TTL (\"time to live\") and a nonce which proves the completion of the required proof of work (see Attacks \u2014 Spam). The sender then sends the envelope using an onion request to one or more random Service Nodes within the target swarm (in practice, each request is always sent to 3 service nodes to achieve a high degree of redundancy). These Service Nodes then propagate the message to the remaining nodes in the swarm, and each Service Node stores the message for the duration of its specified TTL. Alice uses an onion request to communicate with three random Service Nodes in Bob\u2019s swarm. Bob then uses an onion request to retrieve said message, by talking to three random Service Nodes in his swarm. Not shown here is the process of Alice\u2019s message being replicated across Bob\u2019s swarm. Synchronous (Online) Routing \u00b6 Session clients expose their online status in the encrypted protobuf of any asynchronous message they send. Along with their online status, a sending client also lists a Service Node in their swarm which they are listening to via onion request. When a Session client receives a message which signals the online status of another client, the receiver sends an onion request to the sender's specified listening node. The recipient also exposes their own listening node to the sender. If this process is successful, both sender and receiver will have knowledge of each others' online status and corresponding listening nodes. Messages may now be sent synchronously through onion requests to the conversing clients' respective listening nodes. Alice uses an onion request to send a message to Bob\u2019s listening node. Bob receives this message using an onion request, then sends a message to Alice\u2019s listening node. Messages sent using this synchronous method do not contain proof of work, and listening nodes do not replicate or store messages. To ensure messages are not lost, receiving clients send acknowledgements after receipt of each message. If either device goes offline, this acknowledgement will not be received, and the client which is still online will fall back to using the above asynchronous method of message transmission. Encryption and the Signal Protocol \u00b6 So far, we have discussed both the transport and storage of messages. However, any secure messaging application also requires message encryption in order to preserve user privacy. In order for messages to maintain perfect forward secrecy (PFS) and deniable authentication, we cannot only encrypt messages using the long-term public keys of each Session client. Instead, Session uses the Signal protocol. The Signal protocol allows clients to maintain PFS and Deniable Authentication in an asynchronous messaging context after initially establishing a session using long-term keys. The Signal protocol achieves perfect forward secrecy through an Extended Triple Diffie-Hellman (X3DH) key agreement protocol and the Double Ratchet protocol for deriving message keys. X3DH works in the following way. Consider clients A and B that want to establish a session. A and B each have a long-term identity key: IK_a, IK_b, respectively. Additionally, each client holds a key signed with their identity key (SK_a, SK_b), that they update on a regular basis. Finally, each client generates a one-time key (OTK) for every session they want to establish. Client A can start a session with client B if it obtains a set of B's \"prekeys\", consisting of IK_b(pub), SK_b(pub), OK_b(pub). A then validates the signature on SK_b, generates an ephemeral key EK_a, and performs a series of Diffie-Hellman derivations: DH1 = DH(IK_a(sec), SK_b(pub)) DH2 = DH(EK_a(sec), IK_b(pub)) DH3 = DH(EK_a(sec), SK_b(pub)) DH4 = DH(EK_a(sec), OK_b(pub)) The DH components are then concatenated and passed through a key derivation function (KDF) to derive a shared secret key K, which is used to initialise the Double Ratchet: K = KDF(DH1 || DH2 || DH3 || DH4) Client A is now ready to start deriving message keys using the Double Ratchet, and thus start communicating with B. In the first message that it sends, A includes IK_a(pub), EK_a(pub) necessary for B to derive K. The Double Ratchet uses a chain of Key derivation functions (KDF), each taking the previous chain key and DH parameters communicated by both clients in each of their messages, and producing the next chain key and the actual message key used for encrypting the next message. Even if some message keys get exposed, only the messages related to those keys would be compromised, and the remaining message history would continue to be hidden (the PFS property) as KDF is a one-way function. Additionally, no future messages would be exposed (the \u201cself healing\u201d property) as the potential attacker would be missing the necessary DH parameters to maintain the ratchet. The Signal protocol obtains deniability through the same scheme by allowing for all ephemeral keys used in the scheme to be left unsigned by both parties. This allows any user to create ephemeral keys for any other user, combine those ephemeral keys with their own long term and ephemeral keys to produce plausible yet forged transcripts. The Signal protocol achieves X3DH in an asynchronous environment through the use of prekeys, which contain the required information to asynchronously calculate the ephemeral keys used in the X3DH protocol. In the case of the Signal application, prekeys are stored on a central server, ensuring that these prekeys are available even when a user's device is offline. Modifications to the Signal Protocol \u00b6 Session does not modify the fundamentals of the Signal protocol. However, in order to avoid using centralised servers, we have made some changes to the sharing of prekey bundles. In Session, the sharing of prekey bundles is conducted through the 'friend request' system (see below). We also add additional information to each message, for the purpose of routing the message to its desired recipient and verifying that it was created correctly. Friend Requests \u00b6 Friend requests are sent the first time a client initiates communication with a new contact. Friend requests contain a short message with a written introduction, the sender's prekey bundle, and meta-information like the sender's display name and public key, which the recipient can use to respond. Friend requests are encrypted for the public key of the recipient using ECDH. When a friend request is received, the client can choose whether to accept it. Upon acceptance, the client can use the prekey bundle to begin a session as per the original Signal protocol, and start sending messages asynchronously.","title":"Message Routing"},{"location":"Messenger/message_routing/#message-routing","text":"Session follows one of two distinct cases for message routing, depending on the availability of participating clients:","title":"Message Routing"},{"location":"Messenger/message_routing/#asynchronous-offline-routing","text":"By default, or when either of the participating clients' statuses is determined as offline (see Synchronous Routing for how client status is determined), Session will use asynchronous routing. In asynchronous routing, the sender determines the recipient's swarm by obtaining the deterministic mapping between the recipient's long-term public key and the currently registered Service Nodes. This information is initially requested from a random Service Node by the sender and updated whenever the client gets an error message in the response that indicates a missing swarm. Once this mapping is determined, the sender creates the message protobuf and packs the protobuf in an envelope with the information to be processed by Service Nodes: the long-term public key of the recipient, a timestamp, TTL (\"time to live\") and a nonce which proves the completion of the required proof of work (see Attacks \u2014 Spam). The sender then sends the envelope using an onion request to one or more random Service Nodes within the target swarm (in practice, each request is always sent to 3 service nodes to achieve a high degree of redundancy). These Service Nodes then propagate the message to the remaining nodes in the swarm, and each Service Node stores the message for the duration of its specified TTL. Alice uses an onion request to communicate with three random Service Nodes in Bob\u2019s swarm. Bob then uses an onion request to retrieve said message, by talking to three random Service Nodes in his swarm. Not shown here is the process of Alice\u2019s message being replicated across Bob\u2019s swarm.","title":"Asynchronous (Offline) Routing"},{"location":"Messenger/message_routing/#synchronous-online-routing","text":"Session clients expose their online status in the encrypted protobuf of any asynchronous message they send. Along with their online status, a sending client also lists a Service Node in their swarm which they are listening to via onion request. When a Session client receives a message which signals the online status of another client, the receiver sends an onion request to the sender's specified listening node. The recipient also exposes their own listening node to the sender. If this process is successful, both sender and receiver will have knowledge of each others' online status and corresponding listening nodes. Messages may now be sent synchronously through onion requests to the conversing clients' respective listening nodes. Alice uses an onion request to send a message to Bob\u2019s listening node. Bob receives this message using an onion request, then sends a message to Alice\u2019s listening node. Messages sent using this synchronous method do not contain proof of work, and listening nodes do not replicate or store messages. To ensure messages are not lost, receiving clients send acknowledgements after receipt of each message. If either device goes offline, this acknowledgement will not be received, and the client which is still online will fall back to using the above asynchronous method of message transmission.","title":"Synchronous (Online) Routing"},{"location":"Messenger/message_routing/#encryption-and-the-signal-protocol","text":"So far, we have discussed both the transport and storage of messages. However, any secure messaging application also requires message encryption in order to preserve user privacy. In order for messages to maintain perfect forward secrecy (PFS) and deniable authentication, we cannot only encrypt messages using the long-term public keys of each Session client. Instead, Session uses the Signal protocol. The Signal protocol allows clients to maintain PFS and Deniable Authentication in an asynchronous messaging context after initially establishing a session using long-term keys. The Signal protocol achieves perfect forward secrecy through an Extended Triple Diffie-Hellman (X3DH) key agreement protocol and the Double Ratchet protocol for deriving message keys. X3DH works in the following way. Consider clients A and B that want to establish a session. A and B each have a long-term identity key: IK_a, IK_b, respectively. Additionally, each client holds a key signed with their identity key (SK_a, SK_b), that they update on a regular basis. Finally, each client generates a one-time key (OTK) for every session they want to establish. Client A can start a session with client B if it obtains a set of B's \"prekeys\", consisting of IK_b(pub), SK_b(pub), OK_b(pub). A then validates the signature on SK_b, generates an ephemeral key EK_a, and performs a series of Diffie-Hellman derivations: DH1 = DH(IK_a(sec), SK_b(pub)) DH2 = DH(EK_a(sec), IK_b(pub)) DH3 = DH(EK_a(sec), SK_b(pub)) DH4 = DH(EK_a(sec), OK_b(pub)) The DH components are then concatenated and passed through a key derivation function (KDF) to derive a shared secret key K, which is used to initialise the Double Ratchet: K = KDF(DH1 || DH2 || DH3 || DH4) Client A is now ready to start deriving message keys using the Double Ratchet, and thus start communicating with B. In the first message that it sends, A includes IK_a(pub), EK_a(pub) necessary for B to derive K. The Double Ratchet uses a chain of Key derivation functions (KDF), each taking the previous chain key and DH parameters communicated by both clients in each of their messages, and producing the next chain key and the actual message key used for encrypting the next message. Even if some message keys get exposed, only the messages related to those keys would be compromised, and the remaining message history would continue to be hidden (the PFS property) as KDF is a one-way function. Additionally, no future messages would be exposed (the \u201cself healing\u201d property) as the potential attacker would be missing the necessary DH parameters to maintain the ratchet. The Signal protocol obtains deniability through the same scheme by allowing for all ephemeral keys used in the scheme to be left unsigned by both parties. This allows any user to create ephemeral keys for any other user, combine those ephemeral keys with their own long term and ephemeral keys to produce plausible yet forged transcripts. The Signal protocol achieves X3DH in an asynchronous environment through the use of prekeys, which contain the required information to asynchronously calculate the ephemeral keys used in the X3DH protocol. In the case of the Signal application, prekeys are stored on a central server, ensuring that these prekeys are available even when a user's device is offline.","title":"Encryption and the Signal Protocol"},{"location":"Messenger/message_routing/#modifications-to-the-signal-protocol","text":"Session does not modify the fundamentals of the Signal protocol. However, in order to avoid using centralised servers, we have made some changes to the sharing of prekey bundles. In Session, the sharing of prekey bundles is conducted through the 'friend request' system (see below). We also add additional information to each message, for the purpose of routing the message to its desired recipient and verifying that it was created correctly.","title":"Modifications to the Signal Protocol"},{"location":"Messenger/message_routing/#friend-requests","text":"Friend requests are sent the first time a client initiates communication with a new contact. Friend requests contain a short message with a written introduction, the sender's prekey bundle, and meta-information like the sender's display name and public key, which the recipient can use to respond. Friend requests are encrypted for the public key of the recipient using ECDH. When a friend request is received, the client can choose whether to accept it. Upon acceptance, the client can use the prekey bundle to begin a session as per the original Signal protocol, and start sending messages asynchronously.","title":"Friend Requests"},{"location":"Messenger/multi_device_setup/","text":"Session multi-device setup \u00b6 Session now features cross-platform multidevice support, allowing you to use the same private key across your devices while maintaining security and privacy. Multidevice support is currently in early alpha, and the setup process is less streamlined than it will be when the feature moves out of alpha. The steps outlined in this guide will help you avoid data loss or other adverse effects when setting up multidevice for your Session. Primary and secondary device \u00b6 Currently Session only supports two devices per account: a primary and secondary device. This is only a temporary limitation; in future more than two devices will be able to be connected to the same account. To get started with multi-device, you'll need to start by deciding which device you want to be your primary device, and which will be your secondary. Requirements: \u00b6 Primary Device: A device with Session downloaded, installed and set up. Primary Public Key: The public key from your primary device generated by the Session. Secondary Device: A device with the Session installed but not initialised to a key. Preparation \u00b6 If you have Session installed on both devices and they both have their own public keys already, you'll need to delete one public key (effectively deleting one of your Session accounts). This device will become your secondary device. Mobile as secondary device \u00b6 If you want your mobile (i.e. smartphone or tablet) to be your secondary device and your mobile copy of Session already has its own public key, delete the Session application and redownload it from the Apple App Store or Google Play Store. Desktop as secondary device \u00b6 If you want your desktop (or laptop) messenger as your secondary device and it already has its own public key, open Session on your desktop or laptop and go to File > Preferences > Clear Data . Setup \u00b6 For this demonstration we are going to have our mobile device as our primary device and a desktop as our secondary. Step 1: Get public address from primary device \u00b6 On your mobile messenger, go into settings by tapping on your profile icon and copy your public key. You will need to send this public key to the device that will be your secondary device. Step 2: Paste public key into secondary device \u00b6 WARNING: Do NOT skip past this step. If you click the Link button on your secondary device before the primary device is ready and waiting you may lose the chance to sync the devices. Your desktop copy of Session should not yet have a public key attached to it. If you already have an account set up on your desktop messenger, jump back to Desktop as a secondary device and clear your data. Upon opening the Session desktop client, you will be prompted with 3 options: Register a new account Restore using seed Link device to an existing account Click Link device to an existing account and paste your public key copied in step 1 . Do not click the LINK button yet. We need to prepare our primary device first. Step 3: Prepare primary device \u00b6 To prepare the primary device, we need to go back into the Settings menu and click the Link Device button. Once the button has been clicked, Session on your primary device will show a new popup saying \"Waiting for Device\". Step 4: Click Link button on secondary device \u00b6 Now you can click the Link button on your desktop copy of Session. Step 5: Authorise connection on your primary device \u00b6 Once you've clicked Link on your secondary device, you will be prompted to authorise the link request on your primary device. Check that the 3 words match between devices, and authorise the request. Congratulations! \u00b6 You've successfully set up a multi-device account on Session. \u00b6","title":"Multi-Device Setup"},{"location":"Messenger/multi_device_setup/#session-multi-device-setup","text":"Session now features cross-platform multidevice support, allowing you to use the same private key across your devices while maintaining security and privacy. Multidevice support is currently in early alpha, and the setup process is less streamlined than it will be when the feature moves out of alpha. The steps outlined in this guide will help you avoid data loss or other adverse effects when setting up multidevice for your Session.","title":"Session multi-device setup"},{"location":"Messenger/multi_device_setup/#primary-and-secondary-device","text":"Currently Session only supports two devices per account: a primary and secondary device. This is only a temporary limitation; in future more than two devices will be able to be connected to the same account. To get started with multi-device, you'll need to start by deciding which device you want to be your primary device, and which will be your secondary.","title":"Primary and secondary device"},{"location":"Messenger/multi_device_setup/#requirements","text":"Primary Device: A device with Session downloaded, installed and set up. Primary Public Key: The public key from your primary device generated by the Session. Secondary Device: A device with the Session installed but not initialised to a key.","title":"Requirements:"},{"location":"Messenger/multi_device_setup/#preparation","text":"If you have Session installed on both devices and they both have their own public keys already, you'll need to delete one public key (effectively deleting one of your Session accounts). This device will become your secondary device.","title":"Preparation"},{"location":"Messenger/multi_device_setup/#mobile-as-secondary-device","text":"If you want your mobile (i.e. smartphone or tablet) to be your secondary device and your mobile copy of Session already has its own public key, delete the Session application and redownload it from the Apple App Store or Google Play Store.","title":"Mobile as secondary device"},{"location":"Messenger/multi_device_setup/#desktop-as-secondary-device","text":"If you want your desktop (or laptop) messenger as your secondary device and it already has its own public key, open Session on your desktop or laptop and go to File > Preferences > Clear Data .","title":"Desktop as secondary device"},{"location":"Messenger/multi_device_setup/#setup","text":"For this demonstration we are going to have our mobile device as our primary device and a desktop as our secondary.","title":"Setup"},{"location":"Messenger/multi_device_setup/#step-1-get-public-address-from-primary-device","text":"On your mobile messenger, go into settings by tapping on your profile icon and copy your public key. You will need to send this public key to the device that will be your secondary device.","title":"Step 1: Get public address from primary device"},{"location":"Messenger/multi_device_setup/#step-2-paste-public-key-into-secondary-device","text":"WARNING: Do NOT skip past this step. If you click the Link button on your secondary device before the primary device is ready and waiting you may lose the chance to sync the devices. Your desktop copy of Session should not yet have a public key attached to it. If you already have an account set up on your desktop messenger, jump back to Desktop as a secondary device and clear your data. Upon opening the Session desktop client, you will be prompted with 3 options: Register a new account Restore using seed Link device to an existing account Click Link device to an existing account and paste your public key copied in step 1 . Do not click the LINK button yet. We need to prepare our primary device first.","title":"Step 2: Paste public key into secondary device"},{"location":"Messenger/multi_device_setup/#step-3-prepare-primary-device","text":"To prepare the primary device, we need to go back into the Settings menu and click the Link Device button. Once the button has been clicked, Session on your primary device will show a new popup saying \"Waiting for Device\".","title":"Step 3: Prepare primary device"},{"location":"Messenger/multi_device_setup/#step-4-click-link-button-on-secondary-device","text":"Now you can click the Link button on your desktop copy of Session.","title":"Step 4: Click Link button on secondary device"},{"location":"Messenger/multi_device_setup/#step-5-authorise-connection-on-your-primary-device","text":"Once you've clicked Link on your secondary device, you will be prompted to authorise the link request on your primary device. Check that the 3 words match between devices, and authorise the request.","title":"Step 5: Authorise connection on your primary device"},{"location":"Messenger/multi_device_setup/#congratulations","text":"","title":"Congratulations!"},{"location":"Messenger/multi_device_setup/#youve-successfully-set-up-a-multi-device-account-on-session","text":"","title":"You've successfully set up a multi-device account on Session."},{"location":"Messenger/multidevice/","text":"Multi-Device \u00b6 Modern messaging applications are expected to sync data (message histories, contact lists, etc.) across multiple devices, ensuring that users are able to move between a laptop and a phone (for example) and continue their conversations where they left off. Such multi-device syncing of messages is more difficult in the context of the Signal protocol since key materials are constantly rotated and deleted after a period of time. This means when messaging other users, an out-of-sync device in a multi-device configuration will encrypt using the wrong keypairs. Sesame, Signal\u2019s session management algorithm, attempts to resolve this, but must rely on a central server to provide a consistent transcript of messages to multiple user devices. Since Session does not rely upon central servers, Session requires a different solution, which we broadly refer to as \u2018Multi-Device.\u2019 Device Linking \u00b6 Once an account has been created on one device (referred to as the primary device), the other device (the secondary device) initiates the linking process, which creates a new public/private key pair. A pairwise channel is established between primary and secondary devices, and the primary device's private keys are shared from the primary device to the secondary device. To the user, it now appears that both primary and secondary devices are using the same public/private key pair. Friend Requests \u00b6 Consider user A with two devices (A1, A2) who wants to start communicating with user B, who also has two devices (B1,B2). User A obtains B\u2019s primary public key, i.e., the pubkey of its primary device (B1), out of band. Using this public key, one of A\u2019s devices (A1) sends a friend request to B\u2019s primary device's swarm containing its prekey bundle and the list of its linked devices (A2). Both primary and secondary devices (B1,B2) scan the primary device's swarm periodically, looking for new friend requests. When A\u2019s friend request is found, either one of the devices is able to accept the friend request and initiate a session with A1. The device that accepts the friend request, say B2, then uses the pre-established pairwise channel to notify the other device (B1) of actions it has taken, and instructs B1 to request a session with all of A\u2019s devices. B2 also establishes any outstanding sessions with A\u2019s devices. Finally, B2 provides A with the public key of all of its own linked devices (B1), so A knows to link them. A and B can now begin communicating in a multi-device setting. Alice sends Bob a friend request with multi-device enabled Sending and Receiving Messages \u00b6 After the initial friend request process, the clients can start communicating. When client A needs to send a message to a multi-device-enabled user B, they deliver the message to all of B's linked devices using the established pairwise sessions. Note that secondary devices only poll the primary\u2019s device swarm for establishing new sessions; regular data messages are associated with the device\u2019s own keys, and thus arrive at the device\u2019s own swarm. If user A also has multiple devices, they additionally send a copy of the message to all of their other devices, which appear in those device's message history as having been sent by them, ensuring that their message history is synced across devices. Multi-device sending: Here, Alice sends a message from her primary device to Bob, who has multi-device enabled. Alice sends a message to Bob\u2019s primary and secondary device swarms. She also sends a message to her own secondary device\u2019s swarm, for later retrieval. Not shown here: Onion requests, swarm message replication Open Groups \u00b6 All open group messages are signed by a user's long-term identity key. Recall that secondary devices have access to the primary device\u2019s long-term identity private key as a result of the linking procedure. The secondary devices thus can sign all open group messages using that key. This ensures that other users in the open group see messages from both the primary and secondary device as coming from the same user (having been signed by the same key).","title":"Multi-Device"},{"location":"Messenger/multidevice/#multi-device","text":"Modern messaging applications are expected to sync data (message histories, contact lists, etc.) across multiple devices, ensuring that users are able to move between a laptop and a phone (for example) and continue their conversations where they left off. Such multi-device syncing of messages is more difficult in the context of the Signal protocol since key materials are constantly rotated and deleted after a period of time. This means when messaging other users, an out-of-sync device in a multi-device configuration will encrypt using the wrong keypairs. Sesame, Signal\u2019s session management algorithm, attempts to resolve this, but must rely on a central server to provide a consistent transcript of messages to multiple user devices. Since Session does not rely upon central servers, Session requires a different solution, which we broadly refer to as \u2018Multi-Device.\u2019","title":"Multi-Device"},{"location":"Messenger/multidevice/#device-linking","text":"Once an account has been created on one device (referred to as the primary device), the other device (the secondary device) initiates the linking process, which creates a new public/private key pair. A pairwise channel is established between primary and secondary devices, and the primary device's private keys are shared from the primary device to the secondary device. To the user, it now appears that both primary and secondary devices are using the same public/private key pair.","title":"Device Linking"},{"location":"Messenger/multidevice/#friend-requests","text":"Consider user A with two devices (A1, A2) who wants to start communicating with user B, who also has two devices (B1,B2). User A obtains B\u2019s primary public key, i.e., the pubkey of its primary device (B1), out of band. Using this public key, one of A\u2019s devices (A1) sends a friend request to B\u2019s primary device's swarm containing its prekey bundle and the list of its linked devices (A2). Both primary and secondary devices (B1,B2) scan the primary device's swarm periodically, looking for new friend requests. When A\u2019s friend request is found, either one of the devices is able to accept the friend request and initiate a session with A1. The device that accepts the friend request, say B2, then uses the pre-established pairwise channel to notify the other device (B1) of actions it has taken, and instructs B1 to request a session with all of A\u2019s devices. B2 also establishes any outstanding sessions with A\u2019s devices. Finally, B2 provides A with the public key of all of its own linked devices (B1), so A knows to link them. A and B can now begin communicating in a multi-device setting. Alice sends Bob a friend request with multi-device enabled","title":"Friend Requests"},{"location":"Messenger/multidevice/#sending-and-receiving-messages","text":"After the initial friend request process, the clients can start communicating. When client A needs to send a message to a multi-device-enabled user B, they deliver the message to all of B's linked devices using the established pairwise sessions. Note that secondary devices only poll the primary\u2019s device swarm for establishing new sessions; regular data messages are associated with the device\u2019s own keys, and thus arrive at the device\u2019s own swarm. If user A also has multiple devices, they additionally send a copy of the message to all of their other devices, which appear in those device's message history as having been sent by them, ensuring that their message history is synced across devices. Multi-device sending: Here, Alice sends a message from her primary device to Bob, who has multi-device enabled. Alice sends a message to Bob\u2019s primary and secondary device swarms. She also sends a message to her own secondary device\u2019s swarm, for later retrieval. Not shown here: Onion requests, swarm message replication","title":"Sending and Receiving Messages"},{"location":"Messenger/multidevice/#open-groups","text":"All open group messages are signed by a user's long-term identity key. Recall that secondary devices have access to the primary device\u2019s long-term identity private key as a result of the linking procedure. The secondary devices thus can sign all open group messages using that key. This ensures that other users in the open group see messages from both the primary and secondary device as coming from the same user (having been signed by the same key).","title":"Open Groups"},{"location":"Messenger/opengroup_setup/","text":"Session Open Group Setup \u00b6 An express REST API for serving persistence history public chat rooms for Session. Open groups are not limited in size as they are hosted by your own server. Please be aware these are PUBLIC groups and sensitive private information should not be shared in this group format. It's run by 2 daemons, the platform servers providing an ADN standard REST API and another with Session specific behaviors (crypto-key registration and enhanced moderation functions). Requirements \u00b6 Hosting with a public IP address make sure you have a working DNS hostname that points to your public IP address. an email address (LetsEncrypt requires this) We recommend you have at least 4GB of free disk space and 512mb of ram (it may runs with less but use at your own risk) Installation \u00b6 1. Install docker (debian) \u00b6 for non-debian-based installation instructions of Docker: https://docs.docker.com/v17.12/install/#server Use this guide for additional troubleshooting help: https://docs.docker.com/v17.12/install/linux/docker-ce/debian/#set-up-the-repository or https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/ Remove any possibly previously installed docker installations \u00b6 sudo apt-get remove docker docker-engine docker.io Install official docker repo \u00b6 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common For Debian \u00b6 curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\" For Ubuntu \u00b6 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" Install and test docker \u00b6 apt-get update sudo apt-get install docker-ce To check to make sure it's all working: docker run hello-world 2. Install docker-compose \u00b6 Create docker-compose script \u00b6 curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose make sure it's executable \u00b6 chmod u+x /usr/local/bin/docker-compose 3. Install SOGS \u00b6 git clone https://github.com/loki-project/session-open-group-server.git Install SOGS git submodules \u00b6 cd session-open-group-server git submodule init git submodule update Make sure permissions on acme.json is correct \u00b6 chmod 600 docker/acme.json Set up config \u00b6 cp loki_template.ini loki.ini Get your PUBKEY \u00b6 replace PUBKEY with your key and run echo \"PUBKEY=true\" >> loki.ini Start it \u00b6 Replace your@email.tld with your email address and yourssl.domain.tld with your public facing hostname. These are required for getting an SSL certification from LetsEncrypt which we will attempt to automatically do for you. EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d Upgrade instruction \u00b6 make sure you're in the loki-messenger-public-server directory EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose down to stop it from running git pull to grab the latest source and configs git submodule init to grab any submodule changes git submodule update to grab any platform/nodepomf changes EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose build to update the local docker images EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d to restart the server Getting Help \u00b6 If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit . Reporting Bugs \u00b6 After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Session public server repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example .","title":"OpenGroup Setup"},{"location":"Messenger/opengroup_setup/#session-open-group-setup","text":"An express REST API for serving persistence history public chat rooms for Session. Open groups are not limited in size as they are hosted by your own server. Please be aware these are PUBLIC groups and sensitive private information should not be shared in this group format. It's run by 2 daemons, the platform servers providing an ADN standard REST API and another with Session specific behaviors (crypto-key registration and enhanced moderation functions).","title":"Session Open Group Setup"},{"location":"Messenger/opengroup_setup/#requirements","text":"Hosting with a public IP address make sure you have a working DNS hostname that points to your public IP address. an email address (LetsEncrypt requires this) We recommend you have at least 4GB of free disk space and 512mb of ram (it may runs with less but use at your own risk)","title":"Requirements"},{"location":"Messenger/opengroup_setup/#installation","text":"","title":"Installation"},{"location":"Messenger/opengroup_setup/#1-install-docker-debian","text":"for non-debian-based installation instructions of Docker: https://docs.docker.com/v17.12/install/#server Use this guide for additional troubleshooting help: https://docs.docker.com/v17.12/install/linux/docker-ce/debian/#set-up-the-repository or https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/","title":"1. Install docker (debian)"},{"location":"Messenger/opengroup_setup/#remove-any-possibly-previously-installed-docker-installations","text":"sudo apt-get remove docker docker-engine docker.io","title":"Remove any possibly previously installed docker installations"},{"location":"Messenger/opengroup_setup/#install-official-docker-repo","text":"sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common","title":"Install official docker repo"},{"location":"Messenger/opengroup_setup/#for-debian","text":"curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable\"","title":"For Debian"},{"location":"Messenger/opengroup_setup/#for-ubuntu","text":"curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"","title":"For Ubuntu"},{"location":"Messenger/opengroup_setup/#install-and-test-docker","text":"apt-get update sudo apt-get install docker-ce To check to make sure it's all working: docker run hello-world","title":"Install and test docker"},{"location":"Messenger/opengroup_setup/#2-install-docker-compose","text":"","title":"2. Install docker-compose"},{"location":"Messenger/opengroup_setup/#create-docker-compose-script","text":"curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose","title":"Create docker-compose script"},{"location":"Messenger/opengroup_setup/#make-sure-its-executable","text":"chmod u+x /usr/local/bin/docker-compose","title":"make sure it's executable"},{"location":"Messenger/opengroup_setup/#3-install-sogs","text":"git clone https://github.com/loki-project/session-open-group-server.git","title":"3. Install SOGS"},{"location":"Messenger/opengroup_setup/#install-sogs-git-submodules","text":"cd session-open-group-server git submodule init git submodule update","title":"Install SOGS git submodules"},{"location":"Messenger/opengroup_setup/#make-sure-permissions-on-acmejson-is-correct","text":"chmod 600 docker/acme.json","title":"Make sure permissions on acme.json is correct"},{"location":"Messenger/opengroup_setup/#set-up-config","text":"cp loki_template.ini loki.ini","title":"Set up config"},{"location":"Messenger/opengroup_setup/#get-your-pubkey","text":"replace PUBKEY with your key and run echo \"PUBKEY=true\" >> loki.ini","title":"Get your PUBKEY"},{"location":"Messenger/opengroup_setup/#start-it","text":"Replace your@email.tld with your email address and yourssl.domain.tld with your public facing hostname. These are required for getting an SSL certification from LetsEncrypt which we will attempt to automatically do for you. EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d","title":"Start it"},{"location":"Messenger/opengroup_setup/#upgrade-instruction","text":"make sure you're in the loki-messenger-public-server directory EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose down to stop it from running git pull to grab the latest source and configs git submodule init to grab any submodule changes git submodule update to grab any platform/nodepomf changes EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose build to update the local docker images EMAIL=your@email.tld DOMAIN=yourssl.domain.tld docker-compose up -d to restart the server","title":"Upgrade instruction"},{"location":"Messenger/opengroup_setup/#getting-help","text":"If something in this guide isn\u2019t making sense, or if you\u2019re running into issues that you can\u2019t identify on your own, the first place to go would be the #lokinet-help channel on discord . Alternatively, you can find help on our other communication channels such as telegram , twitter , or reddit .","title":"Getting Help"},{"location":"Messenger/opengroup_setup/#reporting-bugs","text":"After you have sought out for help through our communication channels and have not come to any solutions we recommend opening up a issue ticket on the Session public server repository. Please use the following Github Issue Template for any github issues created: Github Issue Template Example .","title":"Reporting Bugs"},{"location":"Messenger/testing/","text":"Testing \u00b6 Service Nodes are rewarded for providing services to the network in an honest and consistent manner. Consequently, dishonest Service Nodes must be prevented from refusing to store messages for the network while continuing to collect rewards. This is accomplished through Service Node testing, a network-level system of peer policing. Service Node Testing \u00b6 Every Service Node monitors the state of the Loki blockchain, which periodically generates blocks whose hashes are relatively unpredictable. On every block, Service Nodes use this blockhash to deterministically derive a pair of nodes within each swarm: one to be tested (T) and one to perform verification (V). Since T and V both belong to the same swarm, they are expected to store the same database records. As a way of testing this, Node V selects a random record from its database (verifying that the message indeed belongs to the current swarm) and sends a test request to node T, containing only the record's hash and the current block height h. T is expected to respond with the record's actual data. Note that the official binaries used by honest Service Nodes do not expose an endpoint for retrieving a record by its hash, so a cheating node would generally have to download the entire database from one of its honest peers to search for the requested record, making cheating impractical. When T receives a test request, it first confirms that (T, V) is correct for the specified height h and that h is within some reasonable boundary. It then tries to retrieve the requested record from its own database. Note that due to the nature of message propagation, it is possible for V to hold a record for a message before T first receives it, so T will wait for a short time for the message to arrive, and only then respond to the test. When the requested record is obtained, T can respond to the test with the requested record's data. If V does not receive the response within some acceptable time window or it is incorrect, V reports T to the blockchain as having failed the test. In cases of repeated failures, the Service Nodes as a collective might then decide to decommission or deregister T if it consistently fails storage tests as reported by multiple other Service Nodes.","title":"Testing"},{"location":"Messenger/testing/#testing","text":"Service Nodes are rewarded for providing services to the network in an honest and consistent manner. Consequently, dishonest Service Nodes must be prevented from refusing to store messages for the network while continuing to collect rewards. This is accomplished through Service Node testing, a network-level system of peer policing.","title":"Testing"},{"location":"Messenger/testing/#service-node-testing","text":"Every Service Node monitors the state of the Loki blockchain, which periodically generates blocks whose hashes are relatively unpredictable. On every block, Service Nodes use this blockhash to deterministically derive a pair of nodes within each swarm: one to be tested (T) and one to perform verification (V). Since T and V both belong to the same swarm, they are expected to store the same database records. As a way of testing this, Node V selects a random record from its database (verifying that the message indeed belongs to the current swarm) and sends a test request to node T, containing only the record's hash and the current block height h. T is expected to respond with the record's actual data. Note that the official binaries used by honest Service Nodes do not expose an endpoint for retrieving a record by its hash, so a cheating node would generally have to download the entire database from one of its honest peers to search for the requested record, making cheating impractical. When T receives a test request, it first confirms that (T, V) is correct for the specified height h and that h is within some reasonable boundary. It then tries to retrieve the requested record from its own database. Note that due to the nature of message propagation, it is possible for V to hold a record for a message before T first receives it, so T will wait for a short time for the message to arrive, and only then respond to the test. When the requested record is obtained, T can respond to the test with the requested record's data. If V does not receive the response within some acceptable time window or it is incorrect, V reports T to the blockchain as having failed the test. In cases of repeated failures, the Service Nodes as a collective might then decide to decommission or deregister T if it consistently fails storage tests as reported by multiple other Service Nodes.","title":"Service Node Testing"},{"location":"Messenger/threat_model/","text":"Threat Model \u00b6 It is useful to understand the protections Session provides to users, and the threat model which it is effective in defending against. Protections \u00b6 Session aims to provide the following protections against attackers within the scope of the threat model: Sender Anonymity : The long-term identity key of the sender is only knowable to the member(s) of the conversation, and the IP address of the sender is unknown to all parties except the first hop in the onion routing path. Recipient Anonymity : The IP address of the recipient is unknown to all parties except the first hop in the onion routing path. Data Integrity : Messages are received intact and unmodified, and if messages are modified they appear as corrupted and are discarded. Storage : Messages are stored and available for the duration of their specified time to live. End-to-end encryption : Messages (with the exception of friend requests) maintain the properties of the Off the Record (OTR) messaging protocol, namely Perfect Forward Secrecy and Deniable Authentication. In Scope \u00b6 Service Node Operators - Passive/Action attacks \u00b6 Storage of messages in Session is handled by Service Node operators. Since the Service Node network is permissionless (only sufficient stake is required to join), our threat model considers a highly resourced attacker that has limited financial resources and can only run a fraction of the storage network. A dishonest Service Node operator would be able to perform a range of active or passive attacks. Such passive attacks could include passively reading message headers, logging timestamps of when messages were relayed/received, saving the encrypted contents of a message, and assessing the size of a message. Active attacks could include failing to relay messages, failing to store messages, providing clients with modified messages, and refusing to respond to requests for messages belonging to public keys. Service Nodes also operate the onion request system and thus could also attack it. Active attacks on the onion request system could include dropping arbitrary packets, modifying latency between hops, and modifying packets. Malicious Service Nodes would be able to continue performing these active attacks for as long as they continued to pass inter-Service Node tests. Passive attacks may involve a malicious Service Node collecting and storing all data that passes through it and logging all connections with other Service Nodes. Network adversary - Passive attacks \u00b6 Session\u2019s threat model also considers a local network adversary such as an ISP or local network provider. This adversary can perform passive attacks such as monitoring all traffic it relays, conducting deep packet inspection, or saving relayed packets for later inspection. Out of Scope \u00b6 Attackers who are out of the scope of Session\u2019s threat model may be able to break some of the protections Session aims to provide. Network Adversary \u2014 Active Attacks \u00b6 A network adversary could conduct active attacks including corrupting or rerouting packets, or adding delays. These attacks could compromise the storage and retrieval of messages. This is primarily addressed by encrypting data and using onion requests to store and retrieve messages, making targeted attacks by network adversaries difficult. Global Passive Adversary \u00b6 A global passive adversary (GPA) that can monitor the first and last hops in an onion request path could use traffic analysis to reveal the true IP address of a Session client and the destination that Session client is talking to. This potential attack is a property of the onion request system; onion requests are a low-latency onion routing network, meaning that packets are forwarded to their destinations as fast as possible, with no delays or batching. This behaviour, while beneficial for user experience, makes traffic analysis trivial in the case of a GPA. Out of Band Key Discovery \u00b6 Session cannot protect users from exposing the pseudonymity provided by the public key-based account system. If a user associates their real world identity with their public key, then other parties will be able to discover if they receive new friend requests.","title":"Threat Models"},{"location":"Messenger/threat_model/#threat-model","text":"It is useful to understand the protections Session provides to users, and the threat model which it is effective in defending against.","title":"Threat Model"},{"location":"Messenger/threat_model/#protections","text":"Session aims to provide the following protections against attackers within the scope of the threat model: Sender Anonymity : The long-term identity key of the sender is only knowable to the member(s) of the conversation, and the IP address of the sender is unknown to all parties except the first hop in the onion routing path. Recipient Anonymity : The IP address of the recipient is unknown to all parties except the first hop in the onion routing path. Data Integrity : Messages are received intact and unmodified, and if messages are modified they appear as corrupted and are discarded. Storage : Messages are stored and available for the duration of their specified time to live. End-to-end encryption : Messages (with the exception of friend requests) maintain the properties of the Off the Record (OTR) messaging protocol, namely Perfect Forward Secrecy and Deniable Authentication.","title":"Protections"},{"location":"Messenger/threat_model/#in-scope","text":"","title":"In Scope"},{"location":"Messenger/threat_model/#service-node-operators-passiveaction-attacks","text":"Storage of messages in Session is handled by Service Node operators. Since the Service Node network is permissionless (only sufficient stake is required to join), our threat model considers a highly resourced attacker that has limited financial resources and can only run a fraction of the storage network. A dishonest Service Node operator would be able to perform a range of active or passive attacks. Such passive attacks could include passively reading message headers, logging timestamps of when messages were relayed/received, saving the encrypted contents of a message, and assessing the size of a message. Active attacks could include failing to relay messages, failing to store messages, providing clients with modified messages, and refusing to respond to requests for messages belonging to public keys. Service Nodes also operate the onion request system and thus could also attack it. Active attacks on the onion request system could include dropping arbitrary packets, modifying latency between hops, and modifying packets. Malicious Service Nodes would be able to continue performing these active attacks for as long as they continued to pass inter-Service Node tests. Passive attacks may involve a malicious Service Node collecting and storing all data that passes through it and logging all connections with other Service Nodes.","title":"Service Node Operators - Passive/Action attacks"},{"location":"Messenger/threat_model/#network-adversary-passive-attacks","text":"Session\u2019s threat model also considers a local network adversary such as an ISP or local network provider. This adversary can perform passive attacks such as monitoring all traffic it relays, conducting deep packet inspection, or saving relayed packets for later inspection.","title":"Network adversary - Passive attacks"},{"location":"Messenger/threat_model/#out-of-scope","text":"Attackers who are out of the scope of Session\u2019s threat model may be able to break some of the protections Session aims to provide.","title":"Out of Scope"},{"location":"Messenger/threat_model/#network-adversary-active-attacks","text":"A network adversary could conduct active attacks including corrupting or rerouting packets, or adding delays. These attacks could compromise the storage and retrieval of messages. This is primarily addressed by encrypting data and using onion requests to store and retrieve messages, making targeted attacks by network adversaries difficult.","title":"Network Adversary \u2014 Active Attacks"},{"location":"Messenger/threat_model/#global-passive-adversary","text":"A global passive adversary (GPA) that can monitor the first and last hops in an onion request path could use traffic analysis to reveal the true IP address of a Session client and the destination that Session client is talking to. This potential attack is a property of the onion request system; onion requests are a low-latency onion routing network, meaning that packets are forwarded to their destinations as fast as possible, with no delays or batching. This behaviour, while beneficial for user experience, makes traffic analysis trivial in the case of a GPA.","title":"Global Passive Adversary"},{"location":"Messenger/threat_model/#out-of-band-key-discovery","text":"Session cannot protect users from exposing the pseudonymity provided by the public key-based account system. If a user associates their real world identity with their public key, then other parties will be able to discover if they receive new friend requests.","title":"Out of Band Key Discovery"}]}